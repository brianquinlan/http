// ignore_for_file: prefer_expression_function_bodies

// Autogenerated by jnigen. DO NOT EDIT!


// ignore_for_file: annotate_overrides
// ignore_for_file: argument_type_not_assignable
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: doc_directive_unknown
// ignore_for_file: file_names
// ignore_for_file: inference_failure_on_untyped_parameter
// ignore_for_file: invalid_internal_annotation
// ignore_for_file: invalid_use_of_internal_member
// ignore_for_file: library_prefixes
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: no_leading_underscores_for_library_prefixes
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: only_throw_errors
// ignore_for_file: overridden_fields
// ignore_for_file: prefer_double_quotes
// ignore_for_file: unintended_html_in_doc_comment
// ignore_for_file: unnecessary_cast
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name
// ignore_for_file: use_super_parameters


import 'dart:core' show Object, String, bool, double, int;
import 'dart:core' as _$core;

import 'package:jni/_internal.dart' as _$jni;
import 'package:jni/jni.dart' as _$jni;


/// from: `okhttp3.Request$Builder`
class Request_Builder extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<Request_Builder> $type;

  

  @_$jni.internal
  Request_Builder.fromReference(
    
    _$jni.JReference reference,
  ) :
    $type = type,
    super.fromReference(
      
      reference
    );

  static final _class = _$jni.JClass.forName(r'okhttp3/Request$Builder');

      /// The type which includes information such as the signature of this class.
static const type = $Request_Builder$Type();
}
final class $Request_Builder$Type extends _$jni.JObjType<Request_Builder> {
  

  @_$jni.internal
  const $Request_Builder$Type(
    
  );

  @_$jni.internal
  @_$core.override
  String get signature => r'Lokhttp3/Request$Builder;';

  @_$jni.internal
  @_$core.override
  Request_Builder fromReference(_$jni.JReference reference) => Request_Builder.fromReference(
    
    reference
  );

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($Request_Builder$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Request_Builder$Type) &&
        other is $Request_Builder$Type;
  }
}

/// from: `okhttp3.Request`
class Request extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<Request> $type;

  

  @_$jni.internal
  Request.fromReference(
    
    _$jni.JReference reference,
  ) :
    $type = type,
    super.fromReference(
      
      reference
    );

  static final _class = _$jni.JClass.forName(r'okhttp3/Request');

      /// The type which includes information such as the signature of this class.
static const type = $Request$Type();
  static final _id_-deprecated_url = _class.instanceMethodId(
    r'-deprecated_url',
    r'()Lokhttp3/HttpUrl;',
  );

  static final _-deprecated_url = _$jni.ProtectedJniExtensions
    .lookup<_$jni.NativeFunction<_$jni.JniResult Function(_$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, )>>('globalEnv_CallObjectMethod')
    .asFunction<_$jni.JniResult Function(_$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, )>();
  /// from: `public final okhttp3.HttpUrl -deprecated_url()`
  /// The returned object must be released after use, by calling the [release] method.
  _$jni.JObject -deprecated_url(){
    
    return _-deprecated_url(reference.pointer, _id_-deprecated_url as _$jni.JMethodIDPtr).object(const _$jni.JObjectType());
  }

  static final _id_-deprecated_method = _class.instanceMethodId(
    r'-deprecated_method',
    r'()Ljava/lang/String;',
  );

  static final _-deprecated_method = _$jni.ProtectedJniExtensions
    .lookup<_$jni.NativeFunction<_$jni.JniResult Function(_$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, )>>('globalEnv_CallObjectMethod')
    .asFunction<_$jni.JniResult Function(_$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, )>();
  /// from: `public final java.lang.String -deprecated_method()`
  /// The returned object must be released after use, by calling the [release] method.
  _$jni.JString -deprecated_method(){
    
    return _-deprecated_method(reference.pointer, _id_-deprecated_method as _$jni.JMethodIDPtr).object(const _$jni.JStringType());
  }

  static final _id_-deprecated_headers = _class.instanceMethodId(
    r'-deprecated_headers',
    r'()Lokhttp3/Headers;',
  );

  static final _-deprecated_headers = _$jni.ProtectedJniExtensions
    .lookup<_$jni.NativeFunction<_$jni.JniResult Function(_$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, )>>('globalEnv_CallObjectMethod')
    .asFunction<_$jni.JniResult Function(_$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, )>();
  /// from: `public final okhttp3.Headers -deprecated_headers()`
  /// The returned object must be released after use, by calling the [release] method.
  Headers -deprecated_headers(){
    
    return _-deprecated_headers(reference.pointer, _id_-deprecated_headers as _$jni.JMethodIDPtr).object(const $Headers$Type());
  }

  static final _id_-deprecated_body = _class.instanceMethodId(
    r'-deprecated_body',
    r'()Lokhttp3/RequestBody;',
  );

  static final _-deprecated_body = _$jni.ProtectedJniExtensions
    .lookup<_$jni.NativeFunction<_$jni.JniResult Function(_$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, )>>('globalEnv_CallObjectMethod')
    .asFunction<_$jni.JniResult Function(_$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, )>();
  /// from: `public final okhttp3.RequestBody -deprecated_body()`
  /// The returned object must be released after use, by calling the [release] method.
  RequestBody -deprecated_body(){
    
    return _-deprecated_body(reference.pointer, _id_-deprecated_body as _$jni.JMethodIDPtr).object(const $RequestBody$Type());
  }

  static final _id_-deprecated_cacheControl = _class.instanceMethodId(
    r'-deprecated_cacheControl',
    r'()Lokhttp3/CacheControl;',
  );

  static final _-deprecated_cacheControl = _$jni.ProtectedJniExtensions
    .lookup<_$jni.NativeFunction<_$jni.JniResult Function(_$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, )>>('globalEnv_CallObjectMethod')
    .asFunction<_$jni.JniResult Function(_$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, )>();
  /// from: `public final okhttp3.CacheControl -deprecated_cacheControl()`
  /// The returned object must be released after use, by calling the [release] method.
  _$jni.JObject -deprecated_cacheControl(){
    
    return _-deprecated_cacheControl(reference.pointer, _id_-deprecated_cacheControl as _$jni.JMethodIDPtr).object(const _$jni.JObjectType());
  }

}
final class $Request$Type extends _$jni.JObjType<Request> {
  

  @_$jni.internal
  const $Request$Type(
    
  );

  @_$jni.internal
  @_$core.override
  String get signature => r'Lokhttp3/Request;';

  @_$jni.internal
  @_$core.override
  Request fromReference(_$jni.JReference reference) => Request.fromReference(
    
    reference
  );

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($Request$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Request$Type) &&
        other is $Request$Type;
  }
}

/// from: `okhttp3.RequestBody$Companion`
class RequestBody_Companion extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<RequestBody_Companion> $type;

  

  @_$jni.internal
  RequestBody_Companion.fromReference(
    
    _$jni.JReference reference,
  ) :
    $type = type,
    super.fromReference(
      
      reference
    );

  static final _class = _$jni.JClass.forName(r'okhttp3/RequestBody$Companion');

      /// The type which includes information such as the signature of this class.
static const type = $RequestBody_Companion$Type();
}
final class $RequestBody_Companion$Type extends _$jni.JObjType<RequestBody_Companion> {
  

  @_$jni.internal
  const $RequestBody_Companion$Type(
    
  );

  @_$jni.internal
  @_$core.override
  String get signature => r'Lokhttp3/RequestBody$Companion;';

  @_$jni.internal
  @_$core.override
  RequestBody_Companion fromReference(_$jni.JReference reference) => RequestBody_Companion.fromReference(
    
    reference
  );

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($RequestBody_Companion$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($RequestBody_Companion$Type) &&
        other is $RequestBody_Companion$Type;
  }
}

/// from: `okhttp3.RequestBody`
class RequestBody extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<RequestBody> $type;

  

  @_$jni.internal
  RequestBody.fromReference(
    
    _$jni.JReference reference,
  ) :
    $type = type,
    super.fromReference(
      
      reference
    );

  static final _class = _$jni.JClass.forName(r'okhttp3/RequestBody');

      /// The type which includes information such as the signature of this class.
static const type = $RequestBody$Type();
  static final _id_Companion =
      _class.staticFieldId(
        r'Companion',
        r'Lokhttp3/RequestBody$Companion;',
      );
  /// from: `static public final okhttp3.RequestBody$Companion Companion`
  /// The returned object must be released after use, by calling the [release] method.
static RequestBody_Companion get Companion => _id_Companion.get(_class, const $RequestBody_Companion$Type());

}
final class $RequestBody$Type extends _$jni.JObjType<RequestBody> {
  

  @_$jni.internal
  const $RequestBody$Type(
    
  );

  @_$jni.internal
  @_$core.override
  String get signature => r'Lokhttp3/RequestBody;';

  @_$jni.internal
  @_$core.override
  RequestBody fromReference(_$jni.JReference reference) => RequestBody.fromReference(
    
    reference
  );

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($RequestBody$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($RequestBody$Type) &&
        other is $RequestBody$Type;
  }
}

/// from: `okhttp3.Response$Builder`
class Response_Builder extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<Response_Builder> $type;

  

  @_$jni.internal
  Response_Builder.fromReference(
    
    _$jni.JReference reference,
  ) :
    $type = type,
    super.fromReference(
      
      reference
    );

  static final _class = _$jni.JClass.forName(r'okhttp3/Response$Builder');

      /// The type which includes information such as the signature of this class.
static const type = $Response_Builder$Type();
}
final class $Response_Builder$Type extends _$jni.JObjType<Response_Builder> {
  

  @_$jni.internal
  const $Response_Builder$Type(
    
  );

  @_$jni.internal
  @_$core.override
  String get signature => r'Lokhttp3/Response$Builder;';

  @_$jni.internal
  @_$core.override
  Response_Builder fromReference(_$jni.JReference reference) => Response_Builder.fromReference(
    
    reference
  );

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($Response_Builder$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Response_Builder$Type) &&
        other is $Response_Builder$Type;
  }
}

/// from: `okhttp3.Response`
class Response extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<Response> $type;

  

  @_$jni.internal
  Response.fromReference(
    
    _$jni.JReference reference,
  ) :
    $type = type,
    super.fromReference(
      
      reference
    );

  static final _class = _$jni.JClass.forName(r'okhttp3/Response');

      /// The type which includes information such as the signature of this class.
static const type = $Response$Type();
  static final _id_-deprecated_request = _class.instanceMethodId(
    r'-deprecated_request',
    r'()Lokhttp3/Request;',
  );

  static final _-deprecated_request = _$jni.ProtectedJniExtensions
    .lookup<_$jni.NativeFunction<_$jni.JniResult Function(_$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, )>>('globalEnv_CallObjectMethod')
    .asFunction<_$jni.JniResult Function(_$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, )>();
  /// from: `public final okhttp3.Request -deprecated_request()`
  /// The returned object must be released after use, by calling the [release] method.
  Request -deprecated_request(){
    
    return _-deprecated_request(reference.pointer, _id_-deprecated_request as _$jni.JMethodIDPtr).object(const $Request$Type());
  }

  static final _id_-deprecated_protocol = _class.instanceMethodId(
    r'-deprecated_protocol',
    r'()Lokhttp3/Protocol;',
  );

  static final _-deprecated_protocol = _$jni.ProtectedJniExtensions
    .lookup<_$jni.NativeFunction<_$jni.JniResult Function(_$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, )>>('globalEnv_CallObjectMethod')
    .asFunction<_$jni.JniResult Function(_$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, )>();
  /// from: `public final okhttp3.Protocol -deprecated_protocol()`
  /// The returned object must be released after use, by calling the [release] method.
  _$jni.JObject -deprecated_protocol(){
    
    return _-deprecated_protocol(reference.pointer, _id_-deprecated_protocol as _$jni.JMethodIDPtr).object(const _$jni.JObjectType());
  }

  static final _id_-deprecated_code = _class.instanceMethodId(
    r'-deprecated_code',
    r'()I',
  );

  static final _-deprecated_code = _$jni.ProtectedJniExtensions
    .lookup<_$jni.NativeFunction<_$jni.JniResult Function(_$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, )>>('globalEnv_CallIntMethod')
    .asFunction<_$jni.JniResult Function(_$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, )>();
  /// from: `public final int -deprecated_code()`
  int -deprecated_code(){
    
    return _-deprecated_code(reference.pointer, _id_-deprecated_code as _$jni.JMethodIDPtr).integer;
  }

  static final _id_-deprecated_message = _class.instanceMethodId(
    r'-deprecated_message',
    r'()Ljava/lang/String;',
  );

  static final _-deprecated_message = _$jni.ProtectedJniExtensions
    .lookup<_$jni.NativeFunction<_$jni.JniResult Function(_$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, )>>('globalEnv_CallObjectMethod')
    .asFunction<_$jni.JniResult Function(_$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, )>();
  /// from: `public final java.lang.String -deprecated_message()`
  /// The returned object must be released after use, by calling the [release] method.
  _$jni.JString -deprecated_message(){
    
    return _-deprecated_message(reference.pointer, _id_-deprecated_message as _$jni.JMethodIDPtr).object(const _$jni.JStringType());
  }

  static final _id_-deprecated_handshake = _class.instanceMethodId(
    r'-deprecated_handshake',
    r'()Lokhttp3/Handshake;',
  );

  static final _-deprecated_handshake = _$jni.ProtectedJniExtensions
    .lookup<_$jni.NativeFunction<_$jni.JniResult Function(_$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, )>>('globalEnv_CallObjectMethod')
    .asFunction<_$jni.JniResult Function(_$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, )>();
  /// from: `public final okhttp3.Handshake -deprecated_handshake()`
  /// The returned object must be released after use, by calling the [release] method.
  _$jni.JObject -deprecated_handshake(){
    
    return _-deprecated_handshake(reference.pointer, _id_-deprecated_handshake as _$jni.JMethodIDPtr).object(const _$jni.JObjectType());
  }

  static final _id_-deprecated_headers = _class.instanceMethodId(
    r'-deprecated_headers',
    r'()Lokhttp3/Headers;',
  );

  static final _-deprecated_headers = _$jni.ProtectedJniExtensions
    .lookup<_$jni.NativeFunction<_$jni.JniResult Function(_$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, )>>('globalEnv_CallObjectMethod')
    .asFunction<_$jni.JniResult Function(_$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, )>();
  /// from: `public final okhttp3.Headers -deprecated_headers()`
  /// The returned object must be released after use, by calling the [release] method.
  Headers -deprecated_headers(){
    
    return _-deprecated_headers(reference.pointer, _id_-deprecated_headers as _$jni.JMethodIDPtr).object(const $Headers$Type());
  }

  static final _id_-deprecated_body = _class.instanceMethodId(
    r'-deprecated_body',
    r'()Lokhttp3/ResponseBody;',
  );

  static final _-deprecated_body = _$jni.ProtectedJniExtensions
    .lookup<_$jni.NativeFunction<_$jni.JniResult Function(_$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, )>>('globalEnv_CallObjectMethod')
    .asFunction<_$jni.JniResult Function(_$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, )>();
  /// from: `public final okhttp3.ResponseBody -deprecated_body()`
  /// The returned object must be released after use, by calling the [release] method.
  ResponseBody -deprecated_body(){
    
    return _-deprecated_body(reference.pointer, _id_-deprecated_body as _$jni.JMethodIDPtr).object(const $ResponseBody$Type());
  }

  static final _id_-deprecated_networkResponse = _class.instanceMethodId(
    r'-deprecated_networkResponse',
    r'()Lokhttp3/Response;',
  );

  static final _-deprecated_networkResponse = _$jni.ProtectedJniExtensions
    .lookup<_$jni.NativeFunction<_$jni.JniResult Function(_$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, )>>('globalEnv_CallObjectMethod')
    .asFunction<_$jni.JniResult Function(_$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, )>();
  /// from: `public final okhttp3.Response -deprecated_networkResponse()`
  /// The returned object must be released after use, by calling the [release] method.
  Response -deprecated_networkResponse(){
    
    return _-deprecated_networkResponse(reference.pointer, _id_-deprecated_networkResponse as _$jni.JMethodIDPtr).object(const $Response$Type());
  }

  static final _id_-deprecated_cacheResponse = _class.instanceMethodId(
    r'-deprecated_cacheResponse',
    r'()Lokhttp3/Response;',
  );

  static final _-deprecated_cacheResponse = _$jni.ProtectedJniExtensions
    .lookup<_$jni.NativeFunction<_$jni.JniResult Function(_$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, )>>('globalEnv_CallObjectMethod')
    .asFunction<_$jni.JniResult Function(_$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, )>();
  /// from: `public final okhttp3.Response -deprecated_cacheResponse()`
  /// The returned object must be released after use, by calling the [release] method.
  Response -deprecated_cacheResponse(){
    
    return _-deprecated_cacheResponse(reference.pointer, _id_-deprecated_cacheResponse as _$jni.JMethodIDPtr).object(const $Response$Type());
  }

  static final _id_-deprecated_priorResponse = _class.instanceMethodId(
    r'-deprecated_priorResponse',
    r'()Lokhttp3/Response;',
  );

  static final _-deprecated_priorResponse = _$jni.ProtectedJniExtensions
    .lookup<_$jni.NativeFunction<_$jni.JniResult Function(_$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, )>>('globalEnv_CallObjectMethod')
    .asFunction<_$jni.JniResult Function(_$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, )>();
  /// from: `public final okhttp3.Response -deprecated_priorResponse()`
  /// The returned object must be released after use, by calling the [release] method.
  Response -deprecated_priorResponse(){
    
    return _-deprecated_priorResponse(reference.pointer, _id_-deprecated_priorResponse as _$jni.JMethodIDPtr).object(const $Response$Type());
  }

  static final _id_-deprecated_cacheControl = _class.instanceMethodId(
    r'-deprecated_cacheControl',
    r'()Lokhttp3/CacheControl;',
  );

  static final _-deprecated_cacheControl = _$jni.ProtectedJniExtensions
    .lookup<_$jni.NativeFunction<_$jni.JniResult Function(_$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, )>>('globalEnv_CallObjectMethod')
    .asFunction<_$jni.JniResult Function(_$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, )>();
  /// from: `public final okhttp3.CacheControl -deprecated_cacheControl()`
  /// The returned object must be released after use, by calling the [release] method.
  _$jni.JObject -deprecated_cacheControl(){
    
    return _-deprecated_cacheControl(reference.pointer, _id_-deprecated_cacheControl as _$jni.JMethodIDPtr).object(const _$jni.JObjectType());
  }

  static final _id_-deprecated_sentRequestAtMillis = _class.instanceMethodId(
    r'-deprecated_sentRequestAtMillis',
    r'()J',
  );

  static final _-deprecated_sentRequestAtMillis = _$jni.ProtectedJniExtensions
    .lookup<_$jni.NativeFunction<_$jni.JniResult Function(_$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, )>>('globalEnv_CallLongMethod')
    .asFunction<_$jni.JniResult Function(_$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, )>();
  /// from: `public final long -deprecated_sentRequestAtMillis()`
  int -deprecated_sentRequestAtMillis(){
    
    return _-deprecated_sentRequestAtMillis(reference.pointer, _id_-deprecated_sentRequestAtMillis as _$jni.JMethodIDPtr).long;
  }

  static final _id_-deprecated_receivedResponseAtMillis = _class.instanceMethodId(
    r'-deprecated_receivedResponseAtMillis',
    r'()J',
  );

  static final _-deprecated_receivedResponseAtMillis = _$jni.ProtectedJniExtensions
    .lookup<_$jni.NativeFunction<_$jni.JniResult Function(_$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, )>>('globalEnv_CallLongMethod')
    .asFunction<_$jni.JniResult Function(_$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, )>();
  /// from: `public final long -deprecated_receivedResponseAtMillis()`
  int -deprecated_receivedResponseAtMillis(){
    
    return _-deprecated_receivedResponseAtMillis(reference.pointer, _id_-deprecated_receivedResponseAtMillis as _$jni.JMethodIDPtr).long;
  }

}
final class $Response$Type extends _$jni.JObjType<Response> {
  

  @_$jni.internal
  const $Response$Type(
    
  );

  @_$jni.internal
  @_$core.override
  String get signature => r'Lokhttp3/Response;';

  @_$jni.internal
  @_$core.override
  Response fromReference(_$jni.JReference reference) => Response.fromReference(
    
    reference
  );

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($Response$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Response$Type) &&
        other is $Response$Type;
  }
}

/// from: `okhttp3.ResponseBody$BomAwareReader`
class ResponseBody_BomAwareReader extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<ResponseBody_BomAwareReader> $type;

  

  @_$jni.internal
  ResponseBody_BomAwareReader.fromReference(
    
    _$jni.JReference reference,
  ) :
    $type = type,
    super.fromReference(
      
      reference
    );

  static final _class = _$jni.JClass.forName(r'okhttp3/ResponseBody$BomAwareReader');

      /// The type which includes information such as the signature of this class.
static const type = $ResponseBody_BomAwareReader$Type();
}
final class $ResponseBody_BomAwareReader$Type extends _$jni.JObjType<ResponseBody_BomAwareReader> {
  

  @_$jni.internal
  const $ResponseBody_BomAwareReader$Type(
    
  );

  @_$jni.internal
  @_$core.override
  String get signature => r'Lokhttp3/ResponseBody$BomAwareReader;';

  @_$jni.internal
  @_$core.override
  ResponseBody_BomAwareReader fromReference(_$jni.JReference reference) => ResponseBody_BomAwareReader.fromReference(
    
    reference
  );

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($ResponseBody_BomAwareReader$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ResponseBody_BomAwareReader$Type) &&
        other is $ResponseBody_BomAwareReader$Type;
  }
}

/// from: `okhttp3.ResponseBody$Companion`
class ResponseBody_Companion extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<ResponseBody_Companion> $type;

  

  @_$jni.internal
  ResponseBody_Companion.fromReference(
    
    _$jni.JReference reference,
  ) :
    $type = type,
    super.fromReference(
      
      reference
    );

  static final _class = _$jni.JClass.forName(r'okhttp3/ResponseBody$Companion');

      /// The type which includes information such as the signature of this class.
static const type = $ResponseBody_Companion$Type();
}
final class $ResponseBody_Companion$Type extends _$jni.JObjType<ResponseBody_Companion> {
  

  @_$jni.internal
  const $ResponseBody_Companion$Type(
    
  );

  @_$jni.internal
  @_$core.override
  String get signature => r'Lokhttp3/ResponseBody$Companion;';

  @_$jni.internal
  @_$core.override
  ResponseBody_Companion fromReference(_$jni.JReference reference) => ResponseBody_Companion.fromReference(
    
    reference
  );

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($ResponseBody_Companion$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ResponseBody_Companion$Type) &&
        other is $ResponseBody_Companion$Type;
  }
}

/// from: `okhttp3.ResponseBody`
class ResponseBody extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<ResponseBody> $type;

  

  @_$jni.internal
  ResponseBody.fromReference(
    
    _$jni.JReference reference,
  ) :
    $type = type,
    super.fromReference(
      
      reference
    );

  static final _class = _$jni.JClass.forName(r'okhttp3/ResponseBody');

      /// The type which includes information such as the signature of this class.
static const type = $ResponseBody$Type();
  static final _id_Companion =
      _class.staticFieldId(
        r'Companion',
        r'Lokhttp3/ResponseBody$Companion;',
      );
  /// from: `static public final okhttp3.ResponseBody$Companion Companion`
  /// The returned object must be released after use, by calling the [release] method.
static ResponseBody_Companion get Companion => _id_Companion.get(_class, const $ResponseBody_Companion$Type());

}
final class $ResponseBody$Type extends _$jni.JObjType<ResponseBody> {
  

  @_$jni.internal
  const $ResponseBody$Type(
    
  );

  @_$jni.internal
  @_$core.override
  String get signature => r'Lokhttp3/ResponseBody;';

  @_$jni.internal
  @_$core.override
  ResponseBody fromReference(_$jni.JReference reference) => ResponseBody.fromReference(
    
    reference
  );

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($ResponseBody$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ResponseBody$Type) &&
        other is $ResponseBody$Type;
  }
}

/// from: `okhttp3.OkHttpClient$Builder`
class OkHttpClient_Builder extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<OkHttpClient_Builder> $type;

  

  @_$jni.internal
  OkHttpClient_Builder.fromReference(
    
    _$jni.JReference reference,
  ) :
    $type = type,
    super.fromReference(
      
      reference
    );

  static final _class = _$jni.JClass.forName(r'okhttp3/OkHttpClient$Builder');

      /// The type which includes information such as the signature of this class.
static const type = $OkHttpClient_Builder$Type();
  static final _id_-addInterceptor = _class.instanceMethodId(
    r'-addInterceptor',
    r'(Lkotlin/jvm/functions/Function1;)Lokhttp3/OkHttpClient$Builder;',
  );

  static final _-addInterceptor = _$jni.ProtectedJniExtensions
    .lookup<_$jni.NativeFunction<_$jni.JniResult Function(_$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>('globalEnv_CallObjectMethod')
    .asFunction<_$jni.JniResult Function(_$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();
  /// from: `public final okhttp3.OkHttpClient$Builder -addInterceptor(kotlin.jvm.functions.Function1 function1)`
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder -addInterceptor(_$jni.JObject function1, ){
    
    return _-addInterceptor(reference.pointer, _id_-addInterceptor as _$jni.JMethodIDPtr, function1.reference.pointer).object(const $OkHttpClient_Builder$Type());
  }

  static final _id_-addNetworkInterceptor = _class.instanceMethodId(
    r'-addNetworkInterceptor',
    r'(Lkotlin/jvm/functions/Function1;)Lokhttp3/OkHttpClient$Builder;',
  );

  static final _-addNetworkInterceptor = _$jni.ProtectedJniExtensions
    .lookup<_$jni.NativeFunction<_$jni.JniResult Function(_$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>('globalEnv_CallObjectMethod')
    .asFunction<_$jni.JniResult Function(_$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();
  /// from: `public final okhttp3.OkHttpClient$Builder -addNetworkInterceptor(kotlin.jvm.functions.Function1 function1)`
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder -addNetworkInterceptor(_$jni.JObject function1, ){
    
    return _-addNetworkInterceptor(reference.pointer, _id_-addNetworkInterceptor as _$jni.JMethodIDPtr, function1.reference.pointer).object(const $OkHttpClient_Builder$Type());
  }

}
final class $OkHttpClient_Builder$Type extends _$jni.JObjType<OkHttpClient_Builder> {
  

  @_$jni.internal
  const $OkHttpClient_Builder$Type(
    
  );

  @_$jni.internal
  @_$core.override
  String get signature => r'Lokhttp3/OkHttpClient$Builder;';

  @_$jni.internal
  @_$core.override
  OkHttpClient_Builder fromReference(_$jni.JReference reference) => OkHttpClient_Builder.fromReference(
    
    reference
  );

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($OkHttpClient_Builder$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($OkHttpClient_Builder$Type) &&
        other is $OkHttpClient_Builder$Type;
  }
}

/// from: `okhttp3.OkHttpClient$Companion`
class OkHttpClient_Companion extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<OkHttpClient_Companion> $type;

  

  @_$jni.internal
  OkHttpClient_Companion.fromReference(
    
    _$jni.JReference reference,
  ) :
    $type = type,
    super.fromReference(
      
      reference
    );

  static final _class = _$jni.JClass.forName(r'okhttp3/OkHttpClient$Companion');

      /// The type which includes information such as the signature of this class.
static const type = $OkHttpClient_Companion$Type();
}
final class $OkHttpClient_Companion$Type extends _$jni.JObjType<OkHttpClient_Companion> {
  

  @_$jni.internal
  const $OkHttpClient_Companion$Type(
    
  );

  @_$jni.internal
  @_$core.override
  String get signature => r'Lokhttp3/OkHttpClient$Companion;';

  @_$jni.internal
  @_$core.override
  OkHttpClient_Companion fromReference(_$jni.JReference reference) => OkHttpClient_Companion.fromReference(
    
    reference
  );

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($OkHttpClient_Companion$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($OkHttpClient_Companion$Type) &&
        other is $OkHttpClient_Companion$Type;
  }
}

/// from: `okhttp3.OkHttpClient`
class OkHttpClient extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<OkHttpClient> $type;

  

  @_$jni.internal
  OkHttpClient.fromReference(
    
    _$jni.JReference reference,
  ) :
    $type = type,
    super.fromReference(
      
      reference
    );

  static final _class = _$jni.JClass.forName(r'okhttp3/OkHttpClient');

      /// The type which includes information such as the signature of this class.
static const type = $OkHttpClient$Type();
  static final _id_Companion =
      _class.staticFieldId(
        r'Companion',
        r'Lokhttp3/OkHttpClient$Companion;',
      );
  /// from: `static public final okhttp3.OkHttpClient$Companion Companion`
  /// The returned object must be released after use, by calling the [release] method.
static OkHttpClient_Companion get Companion => _id_Companion.get(_class, const $OkHttpClient_Companion$Type());

  static final _id_-deprecated_dispatcher = _class.instanceMethodId(
    r'-deprecated_dispatcher',
    r'()Lokhttp3/Dispatcher;',
  );

  static final _-deprecated_dispatcher = _$jni.ProtectedJniExtensions
    .lookup<_$jni.NativeFunction<_$jni.JniResult Function(_$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, )>>('globalEnv_CallObjectMethod')
    .asFunction<_$jni.JniResult Function(_$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, )>();
  /// from: `public final okhttp3.Dispatcher -deprecated_dispatcher()`
  /// The returned object must be released after use, by calling the [release] method.
  Dispatcher -deprecated_dispatcher(){
    
    return _-deprecated_dispatcher(reference.pointer, _id_-deprecated_dispatcher as _$jni.JMethodIDPtr).object(const $Dispatcher$Type());
  }

  static final _id_-deprecated_connectionPool = _class.instanceMethodId(
    r'-deprecated_connectionPool',
    r'()Lokhttp3/ConnectionPool;',
  );

  static final _-deprecated_connectionPool = _$jni.ProtectedJniExtensions
    .lookup<_$jni.NativeFunction<_$jni.JniResult Function(_$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, )>>('globalEnv_CallObjectMethod')
    .asFunction<_$jni.JniResult Function(_$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, )>();
  /// from: `public final okhttp3.ConnectionPool -deprecated_connectionPool()`
  /// The returned object must be released after use, by calling the [release] method.
  ConnectionPool -deprecated_connectionPool(){
    
    return _-deprecated_connectionPool(reference.pointer, _id_-deprecated_connectionPool as _$jni.JMethodIDPtr).object(const $ConnectionPool$Type());
  }

  static final _id_-deprecated_interceptors = _class.instanceMethodId(
    r'-deprecated_interceptors',
    r'()Ljava/util/List;',
  );

  static final _-deprecated_interceptors = _$jni.ProtectedJniExtensions
    .lookup<_$jni.NativeFunction<_$jni.JniResult Function(_$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, )>>('globalEnv_CallObjectMethod')
    .asFunction<_$jni.JniResult Function(_$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, )>();
  /// from: `public final java.util.List -deprecated_interceptors()`
  /// The returned object must be released after use, by calling the [release] method.
  _$jni.JList<_$jni.JObject> -deprecated_interceptors(){
    
    return _-deprecated_interceptors(reference.pointer, _id_-deprecated_interceptors as _$jni.JMethodIDPtr).object(const _$jni.JListType(_$jni.JObjectType()));
  }

  static final _id_-deprecated_networkInterceptors = _class.instanceMethodId(
    r'-deprecated_networkInterceptors',
    r'()Ljava/util/List;',
  );

  static final _-deprecated_networkInterceptors = _$jni.ProtectedJniExtensions
    .lookup<_$jni.NativeFunction<_$jni.JniResult Function(_$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, )>>('globalEnv_CallObjectMethod')
    .asFunction<_$jni.JniResult Function(_$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, )>();
  /// from: `public final java.util.List -deprecated_networkInterceptors()`
  /// The returned object must be released after use, by calling the [release] method.
  _$jni.JList<_$jni.JObject> -deprecated_networkInterceptors(){
    
    return _-deprecated_networkInterceptors(reference.pointer, _id_-deprecated_networkInterceptors as _$jni.JMethodIDPtr).object(const _$jni.JListType(_$jni.JObjectType()));
  }

  static final _id_-deprecated_eventListenerFactory = _class.instanceMethodId(
    r'-deprecated_eventListenerFactory',
    r'()Lokhttp3/EventListener$Factory;',
  );

  static final _-deprecated_eventListenerFactory = _$jni.ProtectedJniExtensions
    .lookup<_$jni.NativeFunction<_$jni.JniResult Function(_$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, )>>('globalEnv_CallObjectMethod')
    .asFunction<_$jni.JniResult Function(_$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, )>();
  /// from: `public final okhttp3.EventListener$Factory -deprecated_eventListenerFactory()`
  /// The returned object must be released after use, by calling the [release] method.
  _$jni.JObject -deprecated_eventListenerFactory(){
    
    return _-deprecated_eventListenerFactory(reference.pointer, _id_-deprecated_eventListenerFactory as _$jni.JMethodIDPtr).object(const _$jni.JObjectType());
  }

  static final _id_-deprecated_retryOnConnectionFailure = _class.instanceMethodId(
    r'-deprecated_retryOnConnectionFailure',
    r'()Z',
  );

  static final _-deprecated_retryOnConnectionFailure = _$jni.ProtectedJniExtensions
    .lookup<_$jni.NativeFunction<_$jni.JniResult Function(_$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, )>>('globalEnv_CallBooleanMethod')
    .asFunction<_$jni.JniResult Function(_$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, )>();
  /// from: `public final boolean -deprecated_retryOnConnectionFailure()`
  bool -deprecated_retryOnConnectionFailure(){
    
    return _-deprecated_retryOnConnectionFailure(reference.pointer, _id_-deprecated_retryOnConnectionFailure as _$jni.JMethodIDPtr).boolean;
  }

  static final _id_-deprecated_authenticator = _class.instanceMethodId(
    r'-deprecated_authenticator',
    r'()Lokhttp3/Authenticator;',
  );

  static final _-deprecated_authenticator = _$jni.ProtectedJniExtensions
    .lookup<_$jni.NativeFunction<_$jni.JniResult Function(_$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, )>>('globalEnv_CallObjectMethod')
    .asFunction<_$jni.JniResult Function(_$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, )>();
  /// from: `public final okhttp3.Authenticator -deprecated_authenticator()`
  /// The returned object must be released after use, by calling the [release] method.
  _$jni.JObject -deprecated_authenticator(){
    
    return _-deprecated_authenticator(reference.pointer, _id_-deprecated_authenticator as _$jni.JMethodIDPtr).object(const _$jni.JObjectType());
  }

  static final _id_-deprecated_followRedirects = _class.instanceMethodId(
    r'-deprecated_followRedirects',
    r'()Z',
  );

  static final _-deprecated_followRedirects = _$jni.ProtectedJniExtensions
    .lookup<_$jni.NativeFunction<_$jni.JniResult Function(_$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, )>>('globalEnv_CallBooleanMethod')
    .asFunction<_$jni.JniResult Function(_$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, )>();
  /// from: `public final boolean -deprecated_followRedirects()`
  bool -deprecated_followRedirects(){
    
    return _-deprecated_followRedirects(reference.pointer, _id_-deprecated_followRedirects as _$jni.JMethodIDPtr).boolean;
  }

  static final _id_-deprecated_followSslRedirects = _class.instanceMethodId(
    r'-deprecated_followSslRedirects',
    r'()Z',
  );

  static final _-deprecated_followSslRedirects = _$jni.ProtectedJniExtensions
    .lookup<_$jni.NativeFunction<_$jni.JniResult Function(_$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, )>>('globalEnv_CallBooleanMethod')
    .asFunction<_$jni.JniResult Function(_$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, )>();
  /// from: `public final boolean -deprecated_followSslRedirects()`
  bool -deprecated_followSslRedirects(){
    
    return _-deprecated_followSslRedirects(reference.pointer, _id_-deprecated_followSslRedirects as _$jni.JMethodIDPtr).boolean;
  }

  static final _id_-deprecated_cookieJar = _class.instanceMethodId(
    r'-deprecated_cookieJar',
    r'()Lokhttp3/CookieJar;',
  );

  static final _-deprecated_cookieJar = _$jni.ProtectedJniExtensions
    .lookup<_$jni.NativeFunction<_$jni.JniResult Function(_$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, )>>('globalEnv_CallObjectMethod')
    .asFunction<_$jni.JniResult Function(_$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, )>();
  /// from: `public final okhttp3.CookieJar -deprecated_cookieJar()`
  /// The returned object must be released after use, by calling the [release] method.
  _$jni.JObject -deprecated_cookieJar(){
    
    return _-deprecated_cookieJar(reference.pointer, _id_-deprecated_cookieJar as _$jni.JMethodIDPtr).object(const _$jni.JObjectType());
  }

  static final _id_-deprecated_cache = _class.instanceMethodId(
    r'-deprecated_cache',
    r'()Lokhttp3/Cache;',
  );

  static final _-deprecated_cache = _$jni.ProtectedJniExtensions
    .lookup<_$jni.NativeFunction<_$jni.JniResult Function(_$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, )>>('globalEnv_CallObjectMethod')
    .asFunction<_$jni.JniResult Function(_$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, )>();
  /// from: `public final okhttp3.Cache -deprecated_cache()`
  /// The returned object must be released after use, by calling the [release] method.
  Cache -deprecated_cache(){
    
    return _-deprecated_cache(reference.pointer, _id_-deprecated_cache as _$jni.JMethodIDPtr).object(const $Cache$Type());
  }

  static final _id_-deprecated_dns = _class.instanceMethodId(
    r'-deprecated_dns',
    r'()Lokhttp3/Dns;',
  );

  static final _-deprecated_dns = _$jni.ProtectedJniExtensions
    .lookup<_$jni.NativeFunction<_$jni.JniResult Function(_$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, )>>('globalEnv_CallObjectMethod')
    .asFunction<_$jni.JniResult Function(_$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, )>();
  /// from: `public final okhttp3.Dns -deprecated_dns()`
  /// The returned object must be released after use, by calling the [release] method.
  _$jni.JObject -deprecated_dns(){
    
    return _-deprecated_dns(reference.pointer, _id_-deprecated_dns as _$jni.JMethodIDPtr).object(const _$jni.JObjectType());
  }

  static final _id_-deprecated_proxy = _class.instanceMethodId(
    r'-deprecated_proxy',
    r'()Ljava/net/Proxy;',
  );

  static final _-deprecated_proxy = _$jni.ProtectedJniExtensions
    .lookup<_$jni.NativeFunction<_$jni.JniResult Function(_$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, )>>('globalEnv_CallObjectMethod')
    .asFunction<_$jni.JniResult Function(_$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, )>();
  /// from: `public final java.net.Proxy -deprecated_proxy()`
  /// The returned object must be released after use, by calling the [release] method.
  _$jni.JObject -deprecated_proxy(){
    
    return _-deprecated_proxy(reference.pointer, _id_-deprecated_proxy as _$jni.JMethodIDPtr).object(const _$jni.JObjectType());
  }

  static final _id_-deprecated_proxySelector = _class.instanceMethodId(
    r'-deprecated_proxySelector',
    r'()Ljava/net/ProxySelector;',
  );

  static final _-deprecated_proxySelector = _$jni.ProtectedJniExtensions
    .lookup<_$jni.NativeFunction<_$jni.JniResult Function(_$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, )>>('globalEnv_CallObjectMethod')
    .asFunction<_$jni.JniResult Function(_$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, )>();
  /// from: `public final java.net.ProxySelector -deprecated_proxySelector()`
  /// The returned object must be released after use, by calling the [release] method.
  _$jni.JObject -deprecated_proxySelector(){
    
    return _-deprecated_proxySelector(reference.pointer, _id_-deprecated_proxySelector as _$jni.JMethodIDPtr).object(const _$jni.JObjectType());
  }

  static final _id_-deprecated_proxyAuthenticator = _class.instanceMethodId(
    r'-deprecated_proxyAuthenticator',
    r'()Lokhttp3/Authenticator;',
  );

  static final _-deprecated_proxyAuthenticator = _$jni.ProtectedJniExtensions
    .lookup<_$jni.NativeFunction<_$jni.JniResult Function(_$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, )>>('globalEnv_CallObjectMethod')
    .asFunction<_$jni.JniResult Function(_$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, )>();
  /// from: `public final okhttp3.Authenticator -deprecated_proxyAuthenticator()`
  /// The returned object must be released after use, by calling the [release] method.
  _$jni.JObject -deprecated_proxyAuthenticator(){
    
    return _-deprecated_proxyAuthenticator(reference.pointer, _id_-deprecated_proxyAuthenticator as _$jni.JMethodIDPtr).object(const _$jni.JObjectType());
  }

  static final _id_-deprecated_socketFactory = _class.instanceMethodId(
    r'-deprecated_socketFactory',
    r'()Ljavax/net/SocketFactory;',
  );

  static final _-deprecated_socketFactory = _$jni.ProtectedJniExtensions
    .lookup<_$jni.NativeFunction<_$jni.JniResult Function(_$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, )>>('globalEnv_CallObjectMethod')
    .asFunction<_$jni.JniResult Function(_$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, )>();
  /// from: `public final javax.net.SocketFactory -deprecated_socketFactory()`
  /// The returned object must be released after use, by calling the [release] method.
  _$jni.JObject -deprecated_socketFactory(){
    
    return _-deprecated_socketFactory(reference.pointer, _id_-deprecated_socketFactory as _$jni.JMethodIDPtr).object(const _$jni.JObjectType());
  }

  static final _id_-deprecated_sslSocketFactory = _class.instanceMethodId(
    r'-deprecated_sslSocketFactory',
    r'()Ljavax/net/ssl/SSLSocketFactory;',
  );

  static final _-deprecated_sslSocketFactory = _$jni.ProtectedJniExtensions
    .lookup<_$jni.NativeFunction<_$jni.JniResult Function(_$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, )>>('globalEnv_CallObjectMethod')
    .asFunction<_$jni.JniResult Function(_$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, )>();
  /// from: `public final javax.net.ssl.SSLSocketFactory -deprecated_sslSocketFactory()`
  /// The returned object must be released after use, by calling the [release] method.
  _$jni.JObject -deprecated_sslSocketFactory(){
    
    return _-deprecated_sslSocketFactory(reference.pointer, _id_-deprecated_sslSocketFactory as _$jni.JMethodIDPtr).object(const _$jni.JObjectType());
  }

  static final _id_-deprecated_connectionSpecs = _class.instanceMethodId(
    r'-deprecated_connectionSpecs',
    r'()Ljava/util/List;',
  );

  static final _-deprecated_connectionSpecs = _$jni.ProtectedJniExtensions
    .lookup<_$jni.NativeFunction<_$jni.JniResult Function(_$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, )>>('globalEnv_CallObjectMethod')
    .asFunction<_$jni.JniResult Function(_$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, )>();
  /// from: `public final java.util.List -deprecated_connectionSpecs()`
  /// The returned object must be released after use, by calling the [release] method.
  _$jni.JList<_$jni.JObject> -deprecated_connectionSpecs(){
    
    return _-deprecated_connectionSpecs(reference.pointer, _id_-deprecated_connectionSpecs as _$jni.JMethodIDPtr).object(const _$jni.JListType(_$jni.JObjectType()));
  }

  static final _id_-deprecated_protocols = _class.instanceMethodId(
    r'-deprecated_protocols',
    r'()Ljava/util/List;',
  );

  static final _-deprecated_protocols = _$jni.ProtectedJniExtensions
    .lookup<_$jni.NativeFunction<_$jni.JniResult Function(_$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, )>>('globalEnv_CallObjectMethod')
    .asFunction<_$jni.JniResult Function(_$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, )>();
  /// from: `public final java.util.List -deprecated_protocols()`
  /// The returned object must be released after use, by calling the [release] method.
  _$jni.JList<_$jni.JObject> -deprecated_protocols(){
    
    return _-deprecated_protocols(reference.pointer, _id_-deprecated_protocols as _$jni.JMethodIDPtr).object(const _$jni.JListType(_$jni.JObjectType()));
  }

  static final _id_-deprecated_hostnameVerifier = _class.instanceMethodId(
    r'-deprecated_hostnameVerifier',
    r'()Ljavax/net/ssl/HostnameVerifier;',
  );

  static final _-deprecated_hostnameVerifier = _$jni.ProtectedJniExtensions
    .lookup<_$jni.NativeFunction<_$jni.JniResult Function(_$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, )>>('globalEnv_CallObjectMethod')
    .asFunction<_$jni.JniResult Function(_$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, )>();
  /// from: `public final javax.net.ssl.HostnameVerifier -deprecated_hostnameVerifier()`
  /// The returned object must be released after use, by calling the [release] method.
  _$jni.JObject -deprecated_hostnameVerifier(){
    
    return _-deprecated_hostnameVerifier(reference.pointer, _id_-deprecated_hostnameVerifier as _$jni.JMethodIDPtr).object(const _$jni.JObjectType());
  }

  static final _id_-deprecated_certificatePinner = _class.instanceMethodId(
    r'-deprecated_certificatePinner',
    r'()Lokhttp3/CertificatePinner;',
  );

  static final _-deprecated_certificatePinner = _$jni.ProtectedJniExtensions
    .lookup<_$jni.NativeFunction<_$jni.JniResult Function(_$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, )>>('globalEnv_CallObjectMethod')
    .asFunction<_$jni.JniResult Function(_$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, )>();
  /// from: `public final okhttp3.CertificatePinner -deprecated_certificatePinner()`
  /// The returned object must be released after use, by calling the [release] method.
  _$jni.JObject -deprecated_certificatePinner(){
    
    return _-deprecated_certificatePinner(reference.pointer, _id_-deprecated_certificatePinner as _$jni.JMethodIDPtr).object(const _$jni.JObjectType());
  }

  static final _id_-deprecated_callTimeoutMillis = _class.instanceMethodId(
    r'-deprecated_callTimeoutMillis',
    r'()I',
  );

  static final _-deprecated_callTimeoutMillis = _$jni.ProtectedJniExtensions
    .lookup<_$jni.NativeFunction<_$jni.JniResult Function(_$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, )>>('globalEnv_CallIntMethod')
    .asFunction<_$jni.JniResult Function(_$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, )>();
  /// from: `public final int -deprecated_callTimeoutMillis()`
  int -deprecated_callTimeoutMillis(){
    
    return _-deprecated_callTimeoutMillis(reference.pointer, _id_-deprecated_callTimeoutMillis as _$jni.JMethodIDPtr).integer;
  }

  static final _id_-deprecated_connectTimeoutMillis = _class.instanceMethodId(
    r'-deprecated_connectTimeoutMillis',
    r'()I',
  );

  static final _-deprecated_connectTimeoutMillis = _$jni.ProtectedJniExtensions
    .lookup<_$jni.NativeFunction<_$jni.JniResult Function(_$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, )>>('globalEnv_CallIntMethod')
    .asFunction<_$jni.JniResult Function(_$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, )>();
  /// from: `public final int -deprecated_connectTimeoutMillis()`
  int -deprecated_connectTimeoutMillis(){
    
    return _-deprecated_connectTimeoutMillis(reference.pointer, _id_-deprecated_connectTimeoutMillis as _$jni.JMethodIDPtr).integer;
  }

  static final _id_-deprecated_readTimeoutMillis = _class.instanceMethodId(
    r'-deprecated_readTimeoutMillis',
    r'()I',
  );

  static final _-deprecated_readTimeoutMillis = _$jni.ProtectedJniExtensions
    .lookup<_$jni.NativeFunction<_$jni.JniResult Function(_$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, )>>('globalEnv_CallIntMethod')
    .asFunction<_$jni.JniResult Function(_$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, )>();
  /// from: `public final int -deprecated_readTimeoutMillis()`
  int -deprecated_readTimeoutMillis(){
    
    return _-deprecated_readTimeoutMillis(reference.pointer, _id_-deprecated_readTimeoutMillis as _$jni.JMethodIDPtr).integer;
  }

  static final _id_-deprecated_writeTimeoutMillis = _class.instanceMethodId(
    r'-deprecated_writeTimeoutMillis',
    r'()I',
  );

  static final _-deprecated_writeTimeoutMillis = _$jni.ProtectedJniExtensions
    .lookup<_$jni.NativeFunction<_$jni.JniResult Function(_$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, )>>('globalEnv_CallIntMethod')
    .asFunction<_$jni.JniResult Function(_$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, )>();
  /// from: `public final int -deprecated_writeTimeoutMillis()`
  int -deprecated_writeTimeoutMillis(){
    
    return _-deprecated_writeTimeoutMillis(reference.pointer, _id_-deprecated_writeTimeoutMillis as _$jni.JMethodIDPtr).integer;
  }

  static final _id_-deprecated_pingIntervalMillis = _class.instanceMethodId(
    r'-deprecated_pingIntervalMillis',
    r'()I',
  );

  static final _-deprecated_pingIntervalMillis = _$jni.ProtectedJniExtensions
    .lookup<_$jni.NativeFunction<_$jni.JniResult Function(_$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, )>>('globalEnv_CallIntMethod')
    .asFunction<_$jni.JniResult Function(_$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, )>();
  /// from: `public final int -deprecated_pingIntervalMillis()`
  int -deprecated_pingIntervalMillis(){
    
    return _-deprecated_pingIntervalMillis(reference.pointer, _id_-deprecated_pingIntervalMillis as _$jni.JMethodIDPtr).integer;
  }

}
final class $OkHttpClient$Type extends _$jni.JObjType<OkHttpClient> {
  

  @_$jni.internal
  const $OkHttpClient$Type(
    
  );

  @_$jni.internal
  @_$core.override
  String get signature => r'Lokhttp3/OkHttpClient;';

  @_$jni.internal
  @_$core.override
  OkHttpClient fromReference(_$jni.JReference reference) => OkHttpClient.fromReference(
    
    reference
  );

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($OkHttpClient$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($OkHttpClient$Type) &&
        other is $OkHttpClient$Type;
  }
}

/// from: `okhttp3.Call$Factory`
class Call_Factory extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<Call_Factory> $type;

  

  @_$jni.internal
  Call_Factory.fromReference(
    
    _$jni.JReference reference,
  ) :
    $type = type,
    super.fromReference(
      
      reference
    );

  static final _class = _$jni.JClass.forName(r'okhttp3/Call$Factory');

      /// The type which includes information such as the signature of this class.
static const type = $Call_Factory$Type();
  /// Maps a specific port to the implemented interface.
  static final _$core.Map<int, $Call_Factory> _$impls = {};
  static _$jni.JObjectPtr _$invoke(
    int port,
    _$jni.JObjectPtr descriptor,
    _$jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      _$jni.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final _$jni.Pointer<
          _$jni.NativeFunction<
              _$jni.JObjectPtr Function(
                  _$jni.Int64, _$jni.JObjectPtr, _$jni.JObjectPtr)>>
      _$invokePointer = _$jni.Pointer.fromFunction(_$invoke);

  static _$jni.Pointer<_$jni.Void> _$invokeMethod(
    int $p,
    _$jni.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
        } catch (e) {
      return _$jni.ProtectedJniExtensions.newDartException(e);
    }
    return _$jni.nullptr;
  }

  static void implementIn(
    _$jni.JImplementer implementer,
    $Call_Factory $impl,
  ) {
    late final _$jni.RawReceivePort $p;
    $p = _$jni.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = _$jni.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      _$jni.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'okhttp3.Call$Factory',
      $p,
      _$invokePointer,
      [
      ],
    );
    final $a = $p.sendPort.nativePort; 
    _$impls[$a] = $impl;
  }

  factory Call_Factory.implement(
    $Call_Factory $impl,
  ) {
    final $i = _$jni.JImplementer();
    implementIn($i, $impl);
    return Call_Factory.fromReference(
      
      $i.implementReference(),
    );
  }
  }
abstract base mixin class $Call_Factory {
  factory $Call_Factory(
    
  ) = _$Call_Factory;

  

}

final class _$Call_Factory with $Call_Factory {
  _$Call_Factory(
    
  );

  


}
final class $Call_Factory$Type extends _$jni.JObjType<Call_Factory> {
  

  @_$jni.internal
  const $Call_Factory$Type(
    
  );

  @_$jni.internal
  @_$core.override
  String get signature => r'Lokhttp3/Call$Factory;';

  @_$jni.internal
  @_$core.override
  Call_Factory fromReference(_$jni.JReference reference) => Call_Factory.fromReference(
    
    reference
  );

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($Call_Factory$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Call_Factory$Type) &&
        other is $Call_Factory$Type;
  }
}

/// from: `okhttp3.Call`
class Call extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<Call> $type;

  

  @_$jni.internal
  Call.fromReference(
    
    _$jni.JReference reference,
  ) :
    $type = type,
    super.fromReference(
      
      reference
    );

  static final _class = _$jni.JClass.forName(r'okhttp3/Call');

      /// The type which includes information such as the signature of this class.
static const type = $Call$Type();
  /// Maps a specific port to the implemented interface.
  static final _$core.Map<int, $Call> _$impls = {};
  static _$jni.JObjectPtr _$invoke(
    int port,
    _$jni.JObjectPtr descriptor,
    _$jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      _$jni.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final _$jni.Pointer<
          _$jni.NativeFunction<
              _$jni.JObjectPtr Function(
                  _$jni.Int64, _$jni.JObjectPtr, _$jni.JObjectPtr)>>
      _$invokePointer = _$jni.Pointer.fromFunction(_$invoke);

  static _$jni.Pointer<_$jni.Void> _$invokeMethod(
    int $p,
    _$jni.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
        } catch (e) {
      return _$jni.ProtectedJniExtensions.newDartException(e);
    }
    return _$jni.nullptr;
  }

  static void implementIn(
    _$jni.JImplementer implementer,
    $Call $impl,
  ) {
    late final _$jni.RawReceivePort $p;
    $p = _$jni.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = _$jni.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      _$jni.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'okhttp3.Call',
      $p,
      _$invokePointer,
      [
      ],
    );
    final $a = $p.sendPort.nativePort; 
    _$impls[$a] = $impl;
  }

  factory Call.implement(
    $Call $impl,
  ) {
    final $i = _$jni.JImplementer();
    implementIn($i, $impl);
    return Call.fromReference(
      
      $i.implementReference(),
    );
  }
  }
abstract base mixin class $Call {
  factory $Call(
    
  ) = _$Call;

  

}

final class _$Call with $Call {
  _$Call(
    
  );

  


}
final class $Call$Type extends _$jni.JObjType<Call> {
  

  @_$jni.internal
  const $Call$Type(
    
  );

  @_$jni.internal
  @_$core.override
  String get signature => r'Lokhttp3/Call;';

  @_$jni.internal
  @_$core.override
  Call fromReference(_$jni.JReference reference) => Call.fromReference(
    
    reference
  );

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($Call$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Call$Type) &&
        other is $Call$Type;
  }
}

/// from: `okhttp3.Headers$Builder`
class Headers_Builder extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<Headers_Builder> $type;

  

  @_$jni.internal
  Headers_Builder.fromReference(
    
    _$jni.JReference reference,
  ) :
    $type = type,
    super.fromReference(
      
      reference
    );

  static final _class = _$jni.JClass.forName(r'okhttp3/Headers$Builder');

      /// The type which includes information such as the signature of this class.
static const type = $Headers_Builder$Type();
}
final class $Headers_Builder$Type extends _$jni.JObjType<Headers_Builder> {
  

  @_$jni.internal
  const $Headers_Builder$Type(
    
  );

  @_$jni.internal
  @_$core.override
  String get signature => r'Lokhttp3/Headers$Builder;';

  @_$jni.internal
  @_$core.override
  Headers_Builder fromReference(_$jni.JReference reference) => Headers_Builder.fromReference(
    
    reference
  );

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($Headers_Builder$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Headers_Builder$Type) &&
        other is $Headers_Builder$Type;
  }
}

/// from: `okhttp3.Headers$Companion`
class Headers_Companion extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<Headers_Companion> $type;

  

  @_$jni.internal
  Headers_Companion.fromReference(
    
    _$jni.JReference reference,
  ) :
    $type = type,
    super.fromReference(
      
      reference
    );

  static final _class = _$jni.JClass.forName(r'okhttp3/Headers$Companion');

      /// The type which includes information such as the signature of this class.
static const type = $Headers_Companion$Type();
  static final _id_-deprecated_of = _class.instanceMethodId(
    r'-deprecated_of',
    r'([Ljava/lang/String;)Lokhttp3/Headers;',
  );

  static final _-deprecated_of = _$jni.ProtectedJniExtensions
    .lookup<_$jni.NativeFunction<_$jni.JniResult Function(_$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>('globalEnv_CallObjectMethod')
    .asFunction<_$jni.JniResult Function(_$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();
  /// from: `public final okhttp3.Headers -deprecated_of(java.lang.String[] strings)`
  /// The returned object must be released after use, by calling the [release] method.
  Headers -deprecated_of(_$jni.JArray<_$jni.JString> strings, ){
    
    return _-deprecated_of(reference.pointer, _id_-deprecated_of as _$jni.JMethodIDPtr, strings.reference.pointer).object(const $Headers$Type());
  }

  static final _id_-deprecated_of$1 = _class.instanceMethodId(
    r'-deprecated_of',
    r'(Ljava/util/Map;)Lokhttp3/Headers;',
  );

  static final _-deprecated_of$1 = _$jni.ProtectedJniExtensions
    .lookup<_$jni.NativeFunction<_$jni.JniResult Function(_$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>('globalEnv_CallObjectMethod')
    .asFunction<_$jni.JniResult Function(_$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();
  /// from: `public final okhttp3.Headers -deprecated_of(java.util.Map map)`
  /// The returned object must be released after use, by calling the [release] method.
  Headers -deprecated_of$1(_$jni.JMap<_$jni.JString, _$jni.JString> map, ){
    
    return _-deprecated_of$1(reference.pointer, _id_-deprecated_of$1 as _$jni.JMethodIDPtr, map.reference.pointer).object(const $Headers$Type());
  }

}
final class $Headers_Companion$Type extends _$jni.JObjType<Headers_Companion> {
  

  @_$jni.internal
  const $Headers_Companion$Type(
    
  );

  @_$jni.internal
  @_$core.override
  String get signature => r'Lokhttp3/Headers$Companion;';

  @_$jni.internal
  @_$core.override
  Headers_Companion fromReference(_$jni.JReference reference) => Headers_Companion.fromReference(
    
    reference
  );

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($Headers_Companion$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Headers_Companion$Type) &&
        other is $Headers_Companion$Type;
  }
}

/// from: `okhttp3.Headers`
class Headers extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<Headers> $type;

  

  @_$jni.internal
  Headers.fromReference(
    
    _$jni.JReference reference,
  ) :
    $type = type,
    super.fromReference(
      
      reference
    );

  static final _class = _$jni.JClass.forName(r'okhttp3/Headers');

      /// The type which includes information such as the signature of this class.
static const type = $Headers$Type();
  static final _id_Companion =
      _class.staticFieldId(
        r'Companion',
        r'Lokhttp3/Headers$Companion;',
      );
  /// from: `static public final okhttp3.Headers$Companion Companion`
  /// The returned object must be released after use, by calling the [release] method.
static Headers_Companion get Companion => _id_Companion.get(_class, const $Headers_Companion$Type());

  static final _id_-deprecated_size = _class.instanceMethodId(
    r'-deprecated_size',
    r'()I',
  );

  static final _-deprecated_size = _$jni.ProtectedJniExtensions
    .lookup<_$jni.NativeFunction<_$jni.JniResult Function(_$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, )>>('globalEnv_CallIntMethod')
    .asFunction<_$jni.JniResult Function(_$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, )>();
  /// from: `public final int -deprecated_size()`
  int -deprecated_size(){
    
    return _-deprecated_size(reference.pointer, _id_-deprecated_size as _$jni.JMethodIDPtr).integer;
  }

}
final class $Headers$Type extends _$jni.JObjType<Headers> {
  

  @_$jni.internal
  const $Headers$Type(
    
  );

  @_$jni.internal
  @_$core.override
  String get signature => r'Lokhttp3/Headers;';

  @_$jni.internal
  @_$core.override
  Headers fromReference(_$jni.JReference reference) => Headers.fromReference(
    
    reference
  );

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($Headers$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Headers$Type) &&
        other is $Headers$Type;
  }
}

/// from: `okhttp3.Callback`
class Callback extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<Callback> $type;

  

  @_$jni.internal
  Callback.fromReference(
    
    _$jni.JReference reference,
  ) :
    $type = type,
    super.fromReference(
      
      reference
    );

  static final _class = _$jni.JClass.forName(r'okhttp3/Callback');

      /// The type which includes information such as the signature of this class.
static const type = $Callback$Type();
  /// Maps a specific port to the implemented interface.
  static final _$core.Map<int, $Callback> _$impls = {};
  static _$jni.JObjectPtr _$invoke(
    int port,
    _$jni.JObjectPtr descriptor,
    _$jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      _$jni.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final _$jni.Pointer<
          _$jni.NativeFunction<
              _$jni.JObjectPtr Function(
                  _$jni.Int64, _$jni.JObjectPtr, _$jni.JObjectPtr)>>
      _$invokePointer = _$jni.Pointer.fromFunction(_$invoke);

  static _$jni.Pointer<_$jni.Void> _$invokeMethod(
    int $p,
    _$jni.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
        } catch (e) {
      return _$jni.ProtectedJniExtensions.newDartException(e);
    }
    return _$jni.nullptr;
  }

  static void implementIn(
    _$jni.JImplementer implementer,
    $Callback $impl,
  ) {
    late final _$jni.RawReceivePort $p;
    $p = _$jni.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = _$jni.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      _$jni.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'okhttp3.Callback',
      $p,
      _$invokePointer,
      [
      ],
    );
    final $a = $p.sendPort.nativePort; 
    _$impls[$a] = $impl;
  }

  factory Callback.implement(
    $Callback $impl,
  ) {
    final $i = _$jni.JImplementer();
    implementIn($i, $impl);
    return Callback.fromReference(
      
      $i.implementReference(),
    );
  }
  }
abstract base mixin class $Callback {
  factory $Callback(
    
  ) = _$Callback;

  

}

final class _$Callback with $Callback {
  _$Callback(
    
  );

  


}
final class $Callback$Type extends _$jni.JObjType<Callback> {
  

  @_$jni.internal
  const $Callback$Type(
    
  );

  @_$jni.internal
  @_$core.override
  String get signature => r'Lokhttp3/Callback;';

  @_$jni.internal
  @_$core.override
  Callback fromReference(_$jni.JReference reference) => Callback.fromReference(
    
    reference
  );

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($Callback$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Callback$Type) &&
        other is $Callback$Type;
  }
}

/// from: `okhttp3.ConnectionPool`
class ConnectionPool extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<ConnectionPool> $type;

  

  @_$jni.internal
  ConnectionPool.fromReference(
    
    _$jni.JReference reference,
  ) :
    $type = type,
    super.fromReference(
      
      reference
    );

  static final _class = _$jni.JClass.forName(r'okhttp3/ConnectionPool');

      /// The type which includes information such as the signature of this class.
static const type = $ConnectionPool$Type();
}
final class $ConnectionPool$Type extends _$jni.JObjType<ConnectionPool> {
  

  @_$jni.internal
  const $ConnectionPool$Type(
    
  );

  @_$jni.internal
  @_$core.override
  String get signature => r'Lokhttp3/ConnectionPool;';

  @_$jni.internal
  @_$core.override
  ConnectionPool fromReference(_$jni.JReference reference) => ConnectionPool.fromReference(
    
    reference
  );

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($ConnectionPool$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ConnectionPool$Type) &&
        other is $ConnectionPool$Type;
  }
}

/// from: `okhttp3.Dispatcher`
class Dispatcher extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<Dispatcher> $type;

  

  @_$jni.internal
  Dispatcher.fromReference(
    
    _$jni.JReference reference,
  ) :
    $type = type,
    super.fromReference(
      
      reference
    );

  static final _class = _$jni.JClass.forName(r'okhttp3/Dispatcher');

      /// The type which includes information such as the signature of this class.
static const type = $Dispatcher$Type();
  static final _id_-deprecated_executorService = _class.instanceMethodId(
    r'-deprecated_executorService',
    r'()Ljava/util/concurrent/ExecutorService;',
  );

  static final _-deprecated_executorService = _$jni.ProtectedJniExtensions
    .lookup<_$jni.NativeFunction<_$jni.JniResult Function(_$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, )>>('globalEnv_CallObjectMethod')
    .asFunction<_$jni.JniResult Function(_$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, )>();
  /// from: `public final java.util.concurrent.ExecutorService -deprecated_executorService()`
  /// The returned object must be released after use, by calling the [release] method.
  ExecutorService -deprecated_executorService(){
    
    return _-deprecated_executorService(reference.pointer, _id_-deprecated_executorService as _$jni.JMethodIDPtr).object(const $ExecutorService$Type());
  }

}
final class $Dispatcher$Type extends _$jni.JObjType<Dispatcher> {
  

  @_$jni.internal
  const $Dispatcher$Type(
    
  );

  @_$jni.internal
  @_$core.override
  String get signature => r'Lokhttp3/Dispatcher;';

  @_$jni.internal
  @_$core.override
  Dispatcher fromReference(_$jni.JReference reference) => Dispatcher.fromReference(
    
    reference
  );

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($Dispatcher$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Dispatcher$Type) &&
        other is $Dispatcher$Type;
  }
}

/// from: `java.util.concurrent.ExecutorService`
class ExecutorService extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<ExecutorService> $type;

  

  @_$jni.internal
  ExecutorService.fromReference(
    
    _$jni.JReference reference,
  ) :
    $type = type,
    super.fromReference(
      
      reference
    );

  static final _class = _$jni.JClass.forName(r'java/util/concurrent/ExecutorService');

      /// The type which includes information such as the signature of this class.
static const type = $ExecutorService$Type();
  static final _id_submit = _class.instanceMethodId(
    r'submit',
    r'(Ljava/util/concurrent/Callable;)Ljava/util/concurrent/Future;',
  );

  static final _submit = _$jni.ProtectedJniExtensions
    .lookup<_$jni.NativeFunction<_$jni.JniResult Function(_$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>('globalEnv_CallObjectMethod')
    .asFunction<_$jni.JniResult Function(_$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();
  /// from: `public abstract java.util.concurrent.Future submit(java.util.concurrent.Callable callable)`
  /// The returned object must be released after use, by calling the [release] method.
  _$jni.JObject submit<$T extends _$jni.JObject>(_$jni.JObject callable, {required _$jni.JObjType<$T> T, }){
    
    return _submit(reference.pointer, _id_submit as _$jni.JMethodIDPtr, callable.reference.pointer).object(const _$jni.JObjectType());
  }

  static final _id_submit$1 = _class.instanceMethodId(
    r'submit',
    r'(Ljava/lang/Runnable;Ljava/lang/Object;)Ljava/util/concurrent/Future;',
  );

  static final _submit$1 = _$jni.ProtectedJniExtensions
    .lookup<_$jni.NativeFunction<_$jni.JniResult Function(_$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>, _$jni.Pointer<_$jni.Void>)>)>>('globalEnv_CallObjectMethod')
    .asFunction<_$jni.JniResult Function(_$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>, _$jni.Pointer<_$jni.Void>)>();
  /// from: `public abstract java.util.concurrent.Future submit(java.lang.Runnable runnable, T object)`
  /// The returned object must be released after use, by calling the [release] method.
  _$jni.JObject submit$1<$T extends _$jni.JObject>(_$jni.JObject runnable, $T object, {_$jni.JObjType<$T>? T, }){
    T ??= _$jni.lowestCommonSuperType([object.$type, ]) as _$jni.JObjType<$T>;
    return _submit$1(reference.pointer, _id_submit$1 as _$jni.JMethodIDPtr, runnable.reference.pointer, object.reference.pointer).object(const _$jni.JObjectType());
  }

  static final _id_submit$2 = _class.instanceMethodId(
    r'submit',
    r'(Ljava/lang/Runnable;)Ljava/util/concurrent/Future;',
  );

  static final _submit$2 = _$jni.ProtectedJniExtensions
    .lookup<_$jni.NativeFunction<_$jni.JniResult Function(_$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>('globalEnv_CallObjectMethod')
    .asFunction<_$jni.JniResult Function(_$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();
  /// from: `public abstract java.util.concurrent.Future submit(java.lang.Runnable runnable)`
  /// The returned object must be released after use, by calling the [release] method.
  _$jni.JObject submit$2(_$jni.JObject runnable, ){
    
    return _submit$2(reference.pointer, _id_submit$2 as _$jni.JMethodIDPtr, runnable.reference.pointer).object(const _$jni.JObjectType());
  }

  static final _id_invokeAll = _class.instanceMethodId(
    r'invokeAll',
    r'(Ljava/util/Collection;)Ljava/util/List;',
  );

  static final _invokeAll = _$jni.ProtectedJniExtensions
    .lookup<_$jni.NativeFunction<_$jni.JniResult Function(_$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>('globalEnv_CallObjectMethod')
    .asFunction<_$jni.JniResult Function(_$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();
  /// from: `public abstract java.util.List invokeAll(java.util.Collection collection)`
  /// The returned object must be released after use, by calling the [release] method.
  _$jni.JList<_$jni.JObject> invokeAll<$T extends _$jni.JObject>(_$jni.JObject collection, {required _$jni.JObjType<$T> T, }){
    
    return _invokeAll(reference.pointer, _id_invokeAll as _$jni.JMethodIDPtr, collection.reference.pointer).object(const _$jni.JListType(_$jni.JObjectType()));
  }

  static final _id_invokeAll$1 = _class.instanceMethodId(
    r'invokeAll',
    r'(Ljava/util/Collection;JLjava/util/concurrent/TimeUnit;)Ljava/util/List;',
  );

  static final _invokeAll$1 = _$jni.ProtectedJniExtensions
    .lookup<_$jni.NativeFunction<_$jni.JniResult Function(_$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>, _$jni.Int64, _$jni.Pointer<_$jni.Void>)>)>>('globalEnv_CallObjectMethod')
    .asFunction<_$jni.JniResult Function(_$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>, int, _$jni.Pointer<_$jni.Void>)>();
  /// from: `public abstract java.util.List invokeAll(java.util.Collection collection, long j, java.util.concurrent.TimeUnit timeUnit)`
  /// The returned object must be released after use, by calling the [release] method.
  _$jni.JList<_$jni.JObject> invokeAll$1<$T extends _$jni.JObject>(_$jni.JObject collection, int j, TimeUnit timeUnit, {required _$jni.JObjType<$T> T, }){
    
    return _invokeAll$1(reference.pointer, _id_invokeAll$1 as _$jni.JMethodIDPtr, collection.reference.pointer, j, timeUnit.reference.pointer).object(const _$jni.JListType(_$jni.JObjectType()));
  }

  static final _id_invokeAny = _class.instanceMethodId(
    r'invokeAny',
    r'(Ljava/util/Collection;)Ljava/lang/Object;',
  );

  static final _invokeAny = _$jni.ProtectedJniExtensions
    .lookup<_$jni.NativeFunction<_$jni.JniResult Function(_$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>('globalEnv_CallObjectMethod')
    .asFunction<_$jni.JniResult Function(_$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();
  /// from: `public abstract T invokeAny(java.util.Collection collection)`
  /// The returned object must be released after use, by calling the [release] method.
  $T invokeAny<$T extends _$jni.JObject>(_$jni.JObject collection, {required _$jni.JObjType<$T> T, }){
    
    return _invokeAny(reference.pointer, _id_invokeAny as _$jni.JMethodIDPtr, collection.reference.pointer).object(T);
  }

  static final _id_invokeAny$1 = _class.instanceMethodId(
    r'invokeAny',
    r'(Ljava/util/Collection;JLjava/util/concurrent/TimeUnit;)Ljava/lang/Object;',
  );

  static final _invokeAny$1 = _$jni.ProtectedJniExtensions
    .lookup<_$jni.NativeFunction<_$jni.JniResult Function(_$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>, _$jni.Int64, _$jni.Pointer<_$jni.Void>)>)>>('globalEnv_CallObjectMethod')
    .asFunction<_$jni.JniResult Function(_$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>, int, _$jni.Pointer<_$jni.Void>)>();
  /// from: `public abstract T invokeAny(java.util.Collection collection, long j, java.util.concurrent.TimeUnit timeUnit)`
  /// The returned object must be released after use, by calling the [release] method.
  $T invokeAny$1<$T extends _$jni.JObject>(_$jni.JObject collection, int j, TimeUnit timeUnit, {required _$jni.JObjType<$T> T, }){
    
    return _invokeAny$1(reference.pointer, _id_invokeAny$1 as _$jni.JMethodIDPtr, collection.reference.pointer, j, timeUnit.reference.pointer).object(T);
  }

  /// Maps a specific port to the implemented interface.
  static final _$core.Map<int, $ExecutorService> _$impls = {};
  static _$jni.JObjectPtr _$invoke(
    int port,
    _$jni.JObjectPtr descriptor,
    _$jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      _$jni.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final _$jni.Pointer<
          _$jni.NativeFunction<
              _$jni.JObjectPtr Function(
                  _$jni.Int64, _$jni.JObjectPtr, _$jni.JObjectPtr)>>
      _$invokePointer = _$jni.Pointer.fromFunction(_$invoke);

  static _$jni.Pointer<_$jni.Void> _$invokeMethod(
    int $p,
    _$jni.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
            if ($d == r'submit(Ljava/util/concurrent/Callable;)Ljava/util/concurrent/Future;') {
          final $r = _$impls[$p]!.submit(
$a[0].as(const _$jni.JObjectType(), releaseOriginal: true),
          );
          return ($r as _$jni.JObject).as(const _$jni.JObjectType()).reference.toPointer();
        }
        if ($d == r'submit(Ljava/lang/Runnable;Ljava/lang/Object;)Ljava/util/concurrent/Future;') {
          final $r = _$impls[$p]!.submit$1(
$a[0].as(const _$jni.JObjectType(), releaseOriginal: true),
$a[1].as(const _$jni.JObjectType(), releaseOriginal: true),
          );
          return ($r as _$jni.JObject).as(const _$jni.JObjectType()).reference.toPointer();
        }
        if ($d == r'submit(Ljava/lang/Runnable;)Ljava/util/concurrent/Future;') {
          final $r = _$impls[$p]!.submit$2(
$a[0].as(const _$jni.JObjectType(), releaseOriginal: true),
          );
          return ($r as _$jni.JObject).as(const _$jni.JObjectType()).reference.toPointer();
        }
        if ($d == r'invokeAll(Ljava/util/Collection;)Ljava/util/List;') {
          final $r = _$impls[$p]!.invokeAll(
$a[0].as(const _$jni.JObjectType(), releaseOriginal: true),
          );
          return ($r as _$jni.JObject).as(const _$jni.JObjectType()).reference.toPointer();
        }
        if ($d == r'invokeAll(Ljava/util/Collection;JLjava/util/concurrent/TimeUnit;)Ljava/util/List;') {
          final $r = _$impls[$p]!.invokeAll$1(
$a[0].as(const _$jni.JObjectType(), releaseOriginal: true),
$a[1].as(const _$jni.JLongType(), releaseOriginal: true).longValue(releaseOriginal: true),
$a[2].as(const $TimeUnit$Type(), releaseOriginal: true),
          );
          return ($r as _$jni.JObject).as(const _$jni.JObjectType()).reference.toPointer();
        }
        if ($d == r'invokeAny(Ljava/util/Collection;)Ljava/lang/Object;') {
          final $r = _$impls[$p]!.invokeAny(
$a[0].as(const _$jni.JObjectType(), releaseOriginal: true),
          );
          return ($r as _$jni.JObject).as(const _$jni.JObjectType()).reference.toPointer();
        }
        if ($d == r'invokeAny(Ljava/util/Collection;JLjava/util/concurrent/TimeUnit;)Ljava/lang/Object;') {
          final $r = _$impls[$p]!.invokeAny$1(
$a[0].as(const _$jni.JObjectType(), releaseOriginal: true),
$a[1].as(const _$jni.JLongType(), releaseOriginal: true).longValue(releaseOriginal: true),
$a[2].as(const $TimeUnit$Type(), releaseOriginal: true),
          );
          return ($r as _$jni.JObject).as(const _$jni.JObjectType()).reference.toPointer();
        }
    } catch (e) {
      return _$jni.ProtectedJniExtensions.newDartException(e);
    }
    return _$jni.nullptr;
  }

  static void implementIn(
    _$jni.JImplementer implementer,
    $ExecutorService $impl,
  ) {
    late final _$jni.RawReceivePort $p;
    $p = _$jni.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = _$jni.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      _$jni.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'java.util.concurrent.ExecutorService',
      $p,
      _$invokePointer,
      [
      ],
    );
    final $a = $p.sendPort.nativePort; 
    _$impls[$a] = $impl;
  }

  factory ExecutorService.implement(
    $ExecutorService $impl,
  ) {
    final $i = _$jni.JImplementer();
    implementIn($i, $impl);
    return ExecutorService.fromReference(
      
      $i.implementReference(),
    );
  }
  }
abstract base mixin class $ExecutorService {
  factory $ExecutorService(
    {required _$jni.JObject Function(_$jni.JObject callable) submit,
    required _$jni.JObject Function(_$jni.JObject runnable, _$jni.JObject object) submit$1,
    required _$jni.JObject Function(_$jni.JObject runnable) submit$2,
    required _$jni.JList<_$jni.JObject> Function(_$jni.JObject collection) invokeAll,
    required _$jni.JList<_$jni.JObject> Function(_$jni.JObject collection, int j, TimeUnit timeUnit) invokeAll$1,
    required _$jni.JObject Function(_$jni.JObject collection) invokeAny,
    required _$jni.JObject Function(_$jni.JObject collection, int j, TimeUnit timeUnit) invokeAny$1,}
  ) = _$ExecutorService;

  

  _$jni.JObject submit(_$jni.JObject callable);
  _$jni.JObject submit$1(_$jni.JObject runnable, _$jni.JObject object);
  _$jni.JObject submit$2(_$jni.JObject runnable);
  _$jni.JList<_$jni.JObject> invokeAll(_$jni.JObject collection);
  _$jni.JList<_$jni.JObject> invokeAll$1(_$jni.JObject collection, int j, TimeUnit timeUnit);
  _$jni.JObject invokeAny(_$jni.JObject collection);
  _$jni.JObject invokeAny$1(_$jni.JObject collection, int j, TimeUnit timeUnit);
}

final class _$ExecutorService with $ExecutorService {
  _$ExecutorService(
    {required _$jni.JObject Function(_$jni.JObject callable) submit,
    required _$jni.JObject Function(_$jni.JObject runnable, _$jni.JObject object) submit$1,
    required _$jni.JObject Function(_$jni.JObject runnable) submit$2,
    required _$jni.JList<_$jni.JObject> Function(_$jni.JObject collection) invokeAll,
    required _$jni.JList<_$jni.JObject> Function(_$jni.JObject collection, int j, TimeUnit timeUnit) invokeAll$1,
    required _$jni.JObject Function(_$jni.JObject collection) invokeAny,
    required _$jni.JObject Function(_$jni.JObject collection, int j, TimeUnit timeUnit) invokeAny$1,}
  ) :  _submit = submit, _submit$1 = submit$1, _submit$2 = submit$2, _invokeAll = invokeAll, _invokeAll$1 = invokeAll$1, _invokeAny = invokeAny, _invokeAny$1 = invokeAny$1;

  

  final _$jni.JObject Function(_$jni.JObject callable) _submit;
  final _$jni.JObject Function(_$jni.JObject runnable, _$jni.JObject object) _submit$1;
  final _$jni.JObject Function(_$jni.JObject runnable) _submit$2;
  final _$jni.JList<_$jni.JObject> Function(_$jni.JObject collection) _invokeAll;
  final _$jni.JList<_$jni.JObject> Function(_$jni.JObject collection, int j, TimeUnit timeUnit) _invokeAll$1;
  final _$jni.JObject Function(_$jni.JObject collection) _invokeAny;
  final _$jni.JObject Function(_$jni.JObject collection, int j, TimeUnit timeUnit) _invokeAny$1;

  _$jni.JObject submit(_$jni.JObject callable) {
    return _submit(callable);
  }  _$jni.JObject submit$1(_$jni.JObject runnable, _$jni.JObject object) {
    return _submit$1(runnable, object);
  }  _$jni.JObject submit$2(_$jni.JObject runnable) {
    return _submit$2(runnable);
  }  _$jni.JList<_$jni.JObject> invokeAll(_$jni.JObject collection) {
    return _invokeAll(collection);
  }  _$jni.JList<_$jni.JObject> invokeAll$1(_$jni.JObject collection, int j, TimeUnit timeUnit) {
    return _invokeAll$1(collection, j, timeUnit);
  }  _$jni.JObject invokeAny(_$jni.JObject collection) {
    return _invokeAny(collection);
  }  _$jni.JObject invokeAny$1(_$jni.JObject collection, int j, TimeUnit timeUnit) {
    return _invokeAny$1(collection, j, timeUnit);
  }}
final class $ExecutorService$Type extends _$jni.JObjType<ExecutorService> {
  

  @_$jni.internal
  const $ExecutorService$Type(
    
  );

  @_$jni.internal
  @_$core.override
  String get signature => r'Ljava/util/concurrent/ExecutorService;';

  @_$jni.internal
  @_$core.override
  ExecutorService fromReference(_$jni.JReference reference) => ExecutorService.fromReference(
    
    reference
  );

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($ExecutorService$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ExecutorService$Type) &&
        other is $ExecutorService$Type;
  }
}

/// from: `okhttp3.Cache$Companion`
class Cache_Companion extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<Cache_Companion> $type;

  

  @_$jni.internal
  Cache_Companion.fromReference(
    
    _$jni.JReference reference,
  ) :
    $type = type,
    super.fromReference(
      
      reference
    );

  static final _class = _$jni.JClass.forName(r'okhttp3/Cache$Companion');

      /// The type which includes information such as the signature of this class.
static const type = $Cache_Companion$Type();
}
final class $Cache_Companion$Type extends _$jni.JObjType<Cache_Companion> {
  

  @_$jni.internal
  const $Cache_Companion$Type(
    
  );

  @_$jni.internal
  @_$core.override
  String get signature => r'Lokhttp3/Cache$Companion;';

  @_$jni.internal
  @_$core.override
  Cache_Companion fromReference(_$jni.JReference reference) => Cache_Companion.fromReference(
    
    reference
  );

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($Cache_Companion$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Cache_Companion$Type) &&
        other is $Cache_Companion$Type;
  }
}

/// from: `okhttp3.Cache$Entry$Companion`
class Cache_Entry_Companion extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<Cache_Entry_Companion> $type;

  

  @_$jni.internal
  Cache_Entry_Companion.fromReference(
    
    _$jni.JReference reference,
  ) :
    $type = type,
    super.fromReference(
      
      reference
    );

  static final _class = _$jni.JClass.forName(r'okhttp3/Cache$Entry$Companion');

      /// The type which includes information such as the signature of this class.
static const type = $Cache_Entry_Companion$Type();
}
final class $Cache_Entry_Companion$Type extends _$jni.JObjType<Cache_Entry_Companion> {
  

  @_$jni.internal
  const $Cache_Entry_Companion$Type(
    
  );

  @_$jni.internal
  @_$core.override
  String get signature => r'Lokhttp3/Cache$Entry$Companion;';

  @_$jni.internal
  @_$core.override
  Cache_Entry_Companion fromReference(_$jni.JReference reference) => Cache_Entry_Companion.fromReference(
    
    reference
  );

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($Cache_Entry_Companion$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Cache_Entry_Companion$Type) &&
        other is $Cache_Entry_Companion$Type;
  }
}

/// from: `okhttp3.Cache`
class Cache extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<Cache> $type;

  

  @_$jni.internal
  Cache.fromReference(
    
    _$jni.JReference reference,
  ) :
    $type = type,
    super.fromReference(
      
      reference
    );

  static final _class = _$jni.JClass.forName(r'okhttp3/Cache');

      /// The type which includes information such as the signature of this class.
static const type = $Cache$Type();
  static final _id_Companion =
      _class.staticFieldId(
        r'Companion',
        r'Lokhttp3/Cache$Companion;',
      );
  /// from: `static public final okhttp3.Cache$Companion Companion`
  /// The returned object must be released after use, by calling the [release] method.
static Cache_Companion get Companion => _id_Companion.get(_class, const $Cache_Companion$Type());

  static final _id_-deprecated_directory = _class.instanceMethodId(
    r'-deprecated_directory',
    r'()Ljava/io/File;',
  );

  static final _-deprecated_directory = _$jni.ProtectedJniExtensions
    .lookup<_$jni.NativeFunction<_$jni.JniResult Function(_$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, )>>('globalEnv_CallObjectMethod')
    .asFunction<_$jni.JniResult Function(_$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, )>();
  /// from: `public final java.io.File -deprecated_directory()`
  /// The returned object must be released after use, by calling the [release] method.
  _$jni.JObject -deprecated_directory(){
    
    return _-deprecated_directory(reference.pointer, _id_-deprecated_directory as _$jni.JMethodIDPtr).object(const _$jni.JObjectType());
  }

}
final class $Cache$Type extends _$jni.JObjType<Cache> {
  

  @_$jni.internal
  const $Cache$Type(
    
  );

  @_$jni.internal
  @_$core.override
  String get signature => r'Lokhttp3/Cache;';

  @_$jni.internal
  @_$core.override
  Cache fromReference(_$jni.JReference reference) => Cache.fromReference(
    
    reference
  );

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($Cache$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Cache$Type) &&
        other is $Cache$Type;
  }
}

/// from: `com.example.ok_http.RedirectReceivedCallback`
class RedirectReceivedCallback extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<RedirectReceivedCallback> $type;

  

  @_$jni.internal
  RedirectReceivedCallback.fromReference(
    
    _$jni.JReference reference,
  ) :
    $type = type,
    super.fromReference(
      
      reference
    );

  static final _class = _$jni.JClass.forName(r'com/example/ok_http/RedirectReceivedCallback');

      /// The type which includes information such as the signature of this class.
static const type = $RedirectReceivedCallback$Type();
  /// Maps a specific port to the implemented interface.
  static final _$core.Map<int, $RedirectReceivedCallback> _$impls = {};
  static _$jni.JObjectPtr _$invoke(
    int port,
    _$jni.JObjectPtr descriptor,
    _$jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      _$jni.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final _$jni.Pointer<
          _$jni.NativeFunction<
              _$jni.JObjectPtr Function(
                  _$jni.Int64, _$jni.JObjectPtr, _$jni.JObjectPtr)>>
      _$invokePointer = _$jni.Pointer.fromFunction(_$invoke);

  static _$jni.Pointer<_$jni.Void> _$invokeMethod(
    int $p,
    _$jni.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
        } catch (e) {
      return _$jni.ProtectedJniExtensions.newDartException(e);
    }
    return _$jni.nullptr;
  }

  static void implementIn(
    _$jni.JImplementer implementer,
    $RedirectReceivedCallback $impl,
  ) {
    late final _$jni.RawReceivePort $p;
    $p = _$jni.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = _$jni.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      _$jni.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'com.example.ok_http.RedirectReceivedCallback',
      $p,
      _$invokePointer,
      [
      ],
    );
    final $a = $p.sendPort.nativePort; 
    _$impls[$a] = $impl;
  }

  factory RedirectReceivedCallback.implement(
    $RedirectReceivedCallback $impl,
  ) {
    final $i = _$jni.JImplementer();
    implementIn($i, $impl);
    return RedirectReceivedCallback.fromReference(
      
      $i.implementReference(),
    );
  }
  }
abstract base mixin class $RedirectReceivedCallback {
  factory $RedirectReceivedCallback(
    
  ) = _$RedirectReceivedCallback;

  

}

final class _$RedirectReceivedCallback with $RedirectReceivedCallback {
  _$RedirectReceivedCallback(
    
  );

  


}
final class $RedirectReceivedCallback$Type extends _$jni.JObjType<RedirectReceivedCallback> {
  

  @_$jni.internal
  const $RedirectReceivedCallback$Type(
    
  );

  @_$jni.internal
  @_$core.override
  String get signature => r'Lcom/example/ok_http/RedirectReceivedCallback;';

  @_$jni.internal
  @_$core.override
  RedirectReceivedCallback fromReference(_$jni.JReference reference) => RedirectReceivedCallback.fromReference(
    
    reference
  );

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($RedirectReceivedCallback$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($RedirectReceivedCallback$Type) &&
        other is $RedirectReceivedCallback$Type;
  }
}

/// from: `com.example.ok_http.RedirectInterceptor$Companion`
class RedirectInterceptor_Companion extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<RedirectInterceptor_Companion> $type;

  

  @_$jni.internal
  RedirectInterceptor_Companion.fromReference(
    
    _$jni.JReference reference,
  ) :
    $type = type,
    super.fromReference(
      
      reference
    );

  static final _class = _$jni.JClass.forName(r'com/example/ok_http/RedirectInterceptor$Companion');

      /// The type which includes information such as the signature of this class.
static const type = $RedirectInterceptor_Companion$Type();
}
final class $RedirectInterceptor_Companion$Type extends _$jni.JObjType<RedirectInterceptor_Companion> {
  

  @_$jni.internal
  const $RedirectInterceptor_Companion$Type(
    
  );

  @_$jni.internal
  @_$core.override
  String get signature => r'Lcom/example/ok_http/RedirectInterceptor$Companion;';

  @_$jni.internal
  @_$core.override
  RedirectInterceptor_Companion fromReference(_$jni.JReference reference) => RedirectInterceptor_Companion.fromReference(
    
    reference
  );

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($RedirectInterceptor_Companion$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($RedirectInterceptor_Companion$Type) &&
        other is $RedirectInterceptor_Companion$Type;
  }
}

/// from: `com.example.ok_http.RedirectInterceptor`
class RedirectInterceptor extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<RedirectInterceptor> $type;

  

  @_$jni.internal
  RedirectInterceptor.fromReference(
    
    _$jni.JReference reference,
  ) :
    $type = type,
    super.fromReference(
      
      reference
    );

  static final _class = _$jni.JClass.forName(r'com/example/ok_http/RedirectInterceptor');

      /// The type which includes information such as the signature of this class.
static const type = $RedirectInterceptor$Type();
  static final _id_Companion =
      _class.staticFieldId(
        r'Companion',
        r'Lcom/example/ok_http/RedirectInterceptor$Companion;',
      );
  /// from: `static public final com.example.ok_http.RedirectInterceptor$Companion Companion`
  /// The returned object must be released after use, by calling the [release] method.
static RedirectInterceptor_Companion get Companion => _id_Companion.get(_class, const $RedirectInterceptor_Companion$Type());

}
final class $RedirectInterceptor$Type extends _$jni.JObjType<RedirectInterceptor> {
  

  @_$jni.internal
  const $RedirectInterceptor$Type(
    
  );

  @_$jni.internal
  @_$core.override
  String get signature => r'Lcom/example/ok_http/RedirectInterceptor;';

  @_$jni.internal
  @_$core.override
  RedirectInterceptor fromReference(_$jni.JReference reference) => RedirectInterceptor.fromReference(
    
    reference
  );

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($RedirectInterceptor$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($RedirectInterceptor$Type) &&
        other is $RedirectInterceptor$Type;
  }
}

/// from: `com.example.ok_http.AsyncInputStreamReader`
class AsyncInputStreamReader extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<AsyncInputStreamReader> $type;

  

  @_$jni.internal
  AsyncInputStreamReader.fromReference(
    
    _$jni.JReference reference,
  ) :
    $type = type,
    super.fromReference(
      
      reference
    );

  static final _class = _$jni.JClass.forName(r'com/example/ok_http/AsyncInputStreamReader');

      /// The type which includes information such as the signature of this class.
static const type = $AsyncInputStreamReader$Type();
}
final class $AsyncInputStreamReader$Type extends _$jni.JObjType<AsyncInputStreamReader> {
  

  @_$jni.internal
  const $AsyncInputStreamReader$Type(
    
  );

  @_$jni.internal
  @_$core.override
  String get signature => r'Lcom/example/ok_http/AsyncInputStreamReader;';

  @_$jni.internal
  @_$core.override
  AsyncInputStreamReader fromReference(_$jni.JReference reference) => AsyncInputStreamReader.fromReference(
    
    reference
  );

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($AsyncInputStreamReader$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($AsyncInputStreamReader$Type) &&
        other is $AsyncInputStreamReader$Type;
  }
}

/// from: `com.example.ok_http.DataCallback`
class DataCallback extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<DataCallback> $type;

  

  @_$jni.internal
  DataCallback.fromReference(
    
    _$jni.JReference reference,
  ) :
    $type = type,
    super.fromReference(
      
      reference
    );

  static final _class = _$jni.JClass.forName(r'com/example/ok_http/DataCallback');

      /// The type which includes information such as the signature of this class.
static const type = $DataCallback$Type();
  /// Maps a specific port to the implemented interface.
  static final _$core.Map<int, $DataCallback> _$impls = {};
  static _$jni.JObjectPtr _$invoke(
    int port,
    _$jni.JObjectPtr descriptor,
    _$jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      _$jni.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final _$jni.Pointer<
          _$jni.NativeFunction<
              _$jni.JObjectPtr Function(
                  _$jni.Int64, _$jni.JObjectPtr, _$jni.JObjectPtr)>>
      _$invokePointer = _$jni.Pointer.fromFunction(_$invoke);

  static _$jni.Pointer<_$jni.Void> _$invokeMethod(
    int $p,
    _$jni.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
        } catch (e) {
      return _$jni.ProtectedJniExtensions.newDartException(e);
    }
    return _$jni.nullptr;
  }

  static void implementIn(
    _$jni.JImplementer implementer,
    $DataCallback $impl,
  ) {
    late final _$jni.RawReceivePort $p;
    $p = _$jni.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = _$jni.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      _$jni.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'com.example.ok_http.DataCallback',
      $p,
      _$invokePointer,
      [
      ],
    );
    final $a = $p.sendPort.nativePort; 
    _$impls[$a] = $impl;
  }

  factory DataCallback.implement(
    $DataCallback $impl,
  ) {
    final $i = _$jni.JImplementer();
    implementIn($i, $impl);
    return DataCallback.fromReference(
      
      $i.implementReference(),
    );
  }
  }
abstract base mixin class $DataCallback {
  factory $DataCallback(
    
  ) = _$DataCallback;

  

}

final class _$DataCallback with $DataCallback {
  _$DataCallback(
    
  );

  


}
final class $DataCallback$Type extends _$jni.JObjType<DataCallback> {
  

  @_$jni.internal
  const $DataCallback$Type(
    
  );

  @_$jni.internal
  @_$core.override
  String get signature => r'Lcom/example/ok_http/DataCallback;';

  @_$jni.internal
  @_$core.override
  DataCallback fromReference(_$jni.JReference reference) => DataCallback.fromReference(
    
    reference
  );

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($DataCallback$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($DataCallback$Type) &&
        other is $DataCallback$Type;
  }
}

/// from: `okhttp3.WebSocket$Factory`
class WebSocket_Factory extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<WebSocket_Factory> $type;

  

  @_$jni.internal
  WebSocket_Factory.fromReference(
    
    _$jni.JReference reference,
  ) :
    $type = type,
    super.fromReference(
      
      reference
    );

  static final _class = _$jni.JClass.forName(r'okhttp3/WebSocket$Factory');

      /// The type which includes information such as the signature of this class.
static const type = $WebSocket_Factory$Type();
  /// Maps a specific port to the implemented interface.
  static final _$core.Map<int, $WebSocket_Factory> _$impls = {};
  static _$jni.JObjectPtr _$invoke(
    int port,
    _$jni.JObjectPtr descriptor,
    _$jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      _$jni.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final _$jni.Pointer<
          _$jni.NativeFunction<
              _$jni.JObjectPtr Function(
                  _$jni.Int64, _$jni.JObjectPtr, _$jni.JObjectPtr)>>
      _$invokePointer = _$jni.Pointer.fromFunction(_$invoke);

  static _$jni.Pointer<_$jni.Void> _$invokeMethod(
    int $p,
    _$jni.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
        } catch (e) {
      return _$jni.ProtectedJniExtensions.newDartException(e);
    }
    return _$jni.nullptr;
  }

  static void implementIn(
    _$jni.JImplementer implementer,
    $WebSocket_Factory $impl,
  ) {
    late final _$jni.RawReceivePort $p;
    $p = _$jni.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = _$jni.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      _$jni.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'okhttp3.WebSocket$Factory',
      $p,
      _$invokePointer,
      [
      ],
    );
    final $a = $p.sendPort.nativePort; 
    _$impls[$a] = $impl;
  }

  factory WebSocket_Factory.implement(
    $WebSocket_Factory $impl,
  ) {
    final $i = _$jni.JImplementer();
    implementIn($i, $impl);
    return WebSocket_Factory.fromReference(
      
      $i.implementReference(),
    );
  }
  }
abstract base mixin class $WebSocket_Factory {
  factory $WebSocket_Factory(
    
  ) = _$WebSocket_Factory;

  

}

final class _$WebSocket_Factory with $WebSocket_Factory {
  _$WebSocket_Factory(
    
  );

  


}
final class $WebSocket_Factory$Type extends _$jni.JObjType<WebSocket_Factory> {
  

  @_$jni.internal
  const $WebSocket_Factory$Type(
    
  );

  @_$jni.internal
  @_$core.override
  String get signature => r'Lokhttp3/WebSocket$Factory;';

  @_$jni.internal
  @_$core.override
  WebSocket_Factory fromReference(_$jni.JReference reference) => WebSocket_Factory.fromReference(
    
    reference
  );

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($WebSocket_Factory$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($WebSocket_Factory$Type) &&
        other is $WebSocket_Factory$Type;
  }
}

/// from: `okhttp3.WebSocket`
class WebSocket extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<WebSocket> $type;

  

  @_$jni.internal
  WebSocket.fromReference(
    
    _$jni.JReference reference,
  ) :
    $type = type,
    super.fromReference(
      
      reference
    );

  static final _class = _$jni.JClass.forName(r'okhttp3/WebSocket');

      /// The type which includes information such as the signature of this class.
static const type = $WebSocket$Type();
  /// Maps a specific port to the implemented interface.
  static final _$core.Map<int, $WebSocket> _$impls = {};
  static _$jni.JObjectPtr _$invoke(
    int port,
    _$jni.JObjectPtr descriptor,
    _$jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      _$jni.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final _$jni.Pointer<
          _$jni.NativeFunction<
              _$jni.JObjectPtr Function(
                  _$jni.Int64, _$jni.JObjectPtr, _$jni.JObjectPtr)>>
      _$invokePointer = _$jni.Pointer.fromFunction(_$invoke);

  static _$jni.Pointer<_$jni.Void> _$invokeMethod(
    int $p,
    _$jni.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
        } catch (e) {
      return _$jni.ProtectedJniExtensions.newDartException(e);
    }
    return _$jni.nullptr;
  }

  static void implementIn(
    _$jni.JImplementer implementer,
    $WebSocket $impl,
  ) {
    late final _$jni.RawReceivePort $p;
    $p = _$jni.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = _$jni.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      _$jni.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'okhttp3.WebSocket',
      $p,
      _$invokePointer,
      [
      ],
    );
    final $a = $p.sendPort.nativePort; 
    _$impls[$a] = $impl;
  }

  factory WebSocket.implement(
    $WebSocket $impl,
  ) {
    final $i = _$jni.JImplementer();
    implementIn($i, $impl);
    return WebSocket.fromReference(
      
      $i.implementReference(),
    );
  }
  }
abstract base mixin class $WebSocket {
  factory $WebSocket(
    
  ) = _$WebSocket;

  

}

final class _$WebSocket with $WebSocket {
  _$WebSocket(
    
  );

  


}
final class $WebSocket$Type extends _$jni.JObjType<WebSocket> {
  

  @_$jni.internal
  const $WebSocket$Type(
    
  );

  @_$jni.internal
  @_$core.override
  String get signature => r'Lokhttp3/WebSocket;';

  @_$jni.internal
  @_$core.override
  WebSocket fromReference(_$jni.JReference reference) => WebSocket.fromReference(
    
    reference
  );

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($WebSocket$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($WebSocket$Type) &&
        other is $WebSocket$Type;
  }
}

/// from: `com.example.ok_http.WebSocketListenerProxy$WebSocketListener`
class WebSocketListenerProxy_WebSocketListener extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<WebSocketListenerProxy_WebSocketListener> $type;

  

  @_$jni.internal
  WebSocketListenerProxy_WebSocketListener.fromReference(
    
    _$jni.JReference reference,
  ) :
    $type = type,
    super.fromReference(
      
      reference
    );

  static final _class = _$jni.JClass.forName(r'com/example/ok_http/WebSocketListenerProxy$WebSocketListener');

      /// The type which includes information such as the signature of this class.
static const type = $WebSocketListenerProxy_WebSocketListener$Type();
  /// Maps a specific port to the implemented interface.
  static final _$core.Map<int, $WebSocketListenerProxy_WebSocketListener> _$impls = {};
  static _$jni.JObjectPtr _$invoke(
    int port,
    _$jni.JObjectPtr descriptor,
    _$jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      _$jni.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final _$jni.Pointer<
          _$jni.NativeFunction<
              _$jni.JObjectPtr Function(
                  _$jni.Int64, _$jni.JObjectPtr, _$jni.JObjectPtr)>>
      _$invokePointer = _$jni.Pointer.fromFunction(_$invoke);

  static _$jni.Pointer<_$jni.Void> _$invokeMethod(
    int $p,
    _$jni.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
        } catch (e) {
      return _$jni.ProtectedJniExtensions.newDartException(e);
    }
    return _$jni.nullptr;
  }

  static void implementIn(
    _$jni.JImplementer implementer,
    $WebSocketListenerProxy_WebSocketListener $impl,
  ) {
    late final _$jni.RawReceivePort $p;
    $p = _$jni.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = _$jni.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      _$jni.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'com.example.ok_http.WebSocketListenerProxy$WebSocketListener',
      $p,
      _$invokePointer,
      [
      ],
    );
    final $a = $p.sendPort.nativePort; 
    _$impls[$a] = $impl;
  }

  factory WebSocketListenerProxy_WebSocketListener.implement(
    $WebSocketListenerProxy_WebSocketListener $impl,
  ) {
    final $i = _$jni.JImplementer();
    implementIn($i, $impl);
    return WebSocketListenerProxy_WebSocketListener.fromReference(
      
      $i.implementReference(),
    );
  }
  }
abstract base mixin class $WebSocketListenerProxy_WebSocketListener {
  factory $WebSocketListenerProxy_WebSocketListener(
    
  ) = _$WebSocketListenerProxy_WebSocketListener;

  

}

final class _$WebSocketListenerProxy_WebSocketListener with $WebSocketListenerProxy_WebSocketListener {
  _$WebSocketListenerProxy_WebSocketListener(
    
  );

  


}
final class $WebSocketListenerProxy_WebSocketListener$Type extends _$jni.JObjType<WebSocketListenerProxy_WebSocketListener> {
  

  @_$jni.internal
  const $WebSocketListenerProxy_WebSocketListener$Type(
    
  );

  @_$jni.internal
  @_$core.override
  String get signature => r'Lcom/example/ok_http/WebSocketListenerProxy$WebSocketListener;';

  @_$jni.internal
  @_$core.override
  WebSocketListenerProxy_WebSocketListener fromReference(_$jni.JReference reference) => WebSocketListenerProxy_WebSocketListener.fromReference(
    
    reference
  );

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($WebSocketListenerProxy_WebSocketListener$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($WebSocketListenerProxy_WebSocketListener$Type) &&
        other is $WebSocketListenerProxy_WebSocketListener$Type;
  }
}

/// from: `com.example.ok_http.WebSocketListenerProxy`
class WebSocketListenerProxy extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<WebSocketListenerProxy> $type;

  

  @_$jni.internal
  WebSocketListenerProxy.fromReference(
    
    _$jni.JReference reference,
  ) :
    $type = type,
    super.fromReference(
      
      reference
    );

  static final _class = _$jni.JClass.forName(r'com/example/ok_http/WebSocketListenerProxy');

      /// The type which includes information such as the signature of this class.
static const type = $WebSocketListenerProxy$Type();
}
final class $WebSocketListenerProxy$Type extends _$jni.JObjType<WebSocketListenerProxy> {
  

  @_$jni.internal
  const $WebSocketListenerProxy$Type(
    
  );

  @_$jni.internal
  @_$core.override
  String get signature => r'Lcom/example/ok_http/WebSocketListenerProxy;';

  @_$jni.internal
  @_$core.override
  WebSocketListenerProxy fromReference(_$jni.JReference reference) => WebSocketListenerProxy.fromReference(
    
    reference
  );

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($WebSocketListenerProxy$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($WebSocketListenerProxy$Type) &&
        other is $WebSocketListenerProxy$Type;
  }
}

/// from: `okio.ByteString$Companion`
class ByteString_Companion extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<ByteString_Companion> $type;

  

  @_$jni.internal
  ByteString_Companion.fromReference(
    
    _$jni.JReference reference,
  ) :
    $type = type,
    super.fromReference(
      
      reference
    );

  static final _class = _$jni.JClass.forName(r'okio/ByteString$Companion');

      /// The type which includes information such as the signature of this class.
static const type = $ByteString_Companion$Type();
  static final _id_-deprecated_decodeBase64 = _class.instanceMethodId(
    r'-deprecated_decodeBase64',
    r'(Ljava/lang/String;)Lokio/ByteString;',
  );

  static final _-deprecated_decodeBase64 = _$jni.ProtectedJniExtensions
    .lookup<_$jni.NativeFunction<_$jni.JniResult Function(_$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>('globalEnv_CallObjectMethod')
    .asFunction<_$jni.JniResult Function(_$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();
  /// from: `public final okio.ByteString -deprecated_decodeBase64(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  ByteString -deprecated_decodeBase64(_$jni.JString string, ){
    
    return _-deprecated_decodeBase64(reference.pointer, _id_-deprecated_decodeBase64 as _$jni.JMethodIDPtr, string.reference.pointer).object(const $ByteString$Type());
  }

  static final _id_-deprecated_decodeHex = _class.instanceMethodId(
    r'-deprecated_decodeHex',
    r'(Ljava/lang/String;)Lokio/ByteString;',
  );

  static final _-deprecated_decodeHex = _$jni.ProtectedJniExtensions
    .lookup<_$jni.NativeFunction<_$jni.JniResult Function(_$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>('globalEnv_CallObjectMethod')
    .asFunction<_$jni.JniResult Function(_$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();
  /// from: `public final okio.ByteString -deprecated_decodeHex(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  ByteString -deprecated_decodeHex(_$jni.JString string, ){
    
    return _-deprecated_decodeHex(reference.pointer, _id_-deprecated_decodeHex as _$jni.JMethodIDPtr, string.reference.pointer).object(const $ByteString$Type());
  }

  static final _id_-deprecated_encodeString = _class.instanceMethodId(
    r'-deprecated_encodeString',
    r'(Ljava/lang/String;Ljava/nio/charset/Charset;)Lokio/ByteString;',
  );

  static final _-deprecated_encodeString = _$jni.ProtectedJniExtensions
    .lookup<_$jni.NativeFunction<_$jni.JniResult Function(_$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>, _$jni.Pointer<_$jni.Void>)>)>>('globalEnv_CallObjectMethod')
    .asFunction<_$jni.JniResult Function(_$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>, _$jni.Pointer<_$jni.Void>)>();
  /// from: `public final okio.ByteString -deprecated_encodeString(java.lang.String string, java.nio.charset.Charset charset)`
  /// The returned object must be released after use, by calling the [release] method.
  ByteString -deprecated_encodeString(_$jni.JString string, _$jni.JObject charset, ){
    
    return _-deprecated_encodeString(reference.pointer, _id_-deprecated_encodeString as _$jni.JMethodIDPtr, string.reference.pointer, charset.reference.pointer).object(const $ByteString$Type());
  }

  static final _id_-deprecated_encodeUtf8 = _class.instanceMethodId(
    r'-deprecated_encodeUtf8',
    r'(Ljava/lang/String;)Lokio/ByteString;',
  );

  static final _-deprecated_encodeUtf8 = _$jni.ProtectedJniExtensions
    .lookup<_$jni.NativeFunction<_$jni.JniResult Function(_$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>('globalEnv_CallObjectMethod')
    .asFunction<_$jni.JniResult Function(_$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();
  /// from: `public final okio.ByteString -deprecated_encodeUtf8(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  ByteString -deprecated_encodeUtf8(_$jni.JString string, ){
    
    return _-deprecated_encodeUtf8(reference.pointer, _id_-deprecated_encodeUtf8 as _$jni.JMethodIDPtr, string.reference.pointer).object(const $ByteString$Type());
  }

  static final _id_-deprecated_of = _class.instanceMethodId(
    r'-deprecated_of',
    r'(Ljava/nio/ByteBuffer;)Lokio/ByteString;',
  );

  static final _-deprecated_of = _$jni.ProtectedJniExtensions
    .lookup<_$jni.NativeFunction<_$jni.JniResult Function(_$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>('globalEnv_CallObjectMethod')
    .asFunction<_$jni.JniResult Function(_$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();
  /// from: `public final okio.ByteString -deprecated_of(java.nio.ByteBuffer byteBuffer)`
  /// The returned object must be released after use, by calling the [release] method.
  ByteString -deprecated_of(_$jni.JByteBuffer byteBuffer, ){
    
    return _-deprecated_of(reference.pointer, _id_-deprecated_of as _$jni.JMethodIDPtr, byteBuffer.reference.pointer).object(const $ByteString$Type());
  }

  static final _id_-deprecated_of$1 = _class.instanceMethodId(
    r'-deprecated_of',
    r'([BII)Lokio/ByteString;',
  );

  static final _-deprecated_of$1 = _$jni.ProtectedJniExtensions
    .lookup<_$jni.NativeFunction<_$jni.JniResult Function(_$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>, _$jni.Int32, _$jni.Int32)>)>>('globalEnv_CallObjectMethod')
    .asFunction<_$jni.JniResult Function(_$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>, int, int)>();
  /// from: `public final okio.ByteString -deprecated_of(byte[] bs, int i, int i1)`
  /// The returned object must be released after use, by calling the [release] method.
  ByteString -deprecated_of$1(_$jni.JArray<_$jni.jbyte> bs, int i, int i1, ){
    
    return _-deprecated_of$1(reference.pointer, _id_-deprecated_of$1 as _$jni.JMethodIDPtr, bs.reference.pointer, i, i1).object(const $ByteString$Type());
  }

  static final _id_-deprecated_read = _class.instanceMethodId(
    r'-deprecated_read',
    r'(Ljava/io/InputStream;I)Lokio/ByteString;',
  );

  static final _-deprecated_read = _$jni.ProtectedJniExtensions
    .lookup<_$jni.NativeFunction<_$jni.JniResult Function(_$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>, _$jni.Int32)>)>>('globalEnv_CallObjectMethod')
    .asFunction<_$jni.JniResult Function(_$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>, int)>();
  /// from: `public final okio.ByteString -deprecated_read(java.io.InputStream inputStream, int i)`
  /// The returned object must be released after use, by calling the [release] method.
  ByteString -deprecated_read(_$jni.JObject inputStream, int i, ){
    
    return _-deprecated_read(reference.pointer, _id_-deprecated_read as _$jni.JMethodIDPtr, inputStream.reference.pointer, i).object(const $ByteString$Type());
  }

}
final class $ByteString_Companion$Type extends _$jni.JObjType<ByteString_Companion> {
  

  @_$jni.internal
  const $ByteString_Companion$Type(
    
  );

  @_$jni.internal
  @_$core.override
  String get signature => r'Lokio/ByteString$Companion;';

  @_$jni.internal
  @_$core.override
  ByteString_Companion fromReference(_$jni.JReference reference) => ByteString_Companion.fromReference(
    
    reference
  );

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($ByteString_Companion$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ByteString_Companion$Type) &&
        other is $ByteString_Companion$Type;
  }
}

/// from: `okio.ByteString`
class ByteString extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<ByteString> $type;

  

  @_$jni.internal
  ByteString.fromReference(
    
    _$jni.JReference reference,
  ) :
    $type = type,
    super.fromReference(
      
      reference
    );

  static final _class = _$jni.JClass.forName(r'okio/ByteString');

      /// The type which includes information such as the signature of this class.
static const type = $ByteString$Type();
  static final _id_Companion =
      _class.staticFieldId(
        r'Companion',
        r'Lokio/ByteString$Companion;',
      );
  /// from: `static public final okio.ByteString$Companion Companion`
  /// The returned object must be released after use, by calling the [release] method.
static ByteString_Companion get Companion => _id_Companion.get(_class, const $ByteString_Companion$Type());

  static final _id_EMPTY =
      _class.staticFieldId(
        r'EMPTY',
        r'Lokio/ByteString;',
      );
  /// from: `static public final okio.ByteString EMPTY`
  /// The returned object must be released after use, by calling the [release] method.
static ByteString get EMPTY => _id_EMPTY.get(_class, const $ByteString$Type());

  static final _id_-deprecated_getByte = _class.instanceMethodId(
    r'-deprecated_getByte',
    r'(I)B',
  );

  static final _-deprecated_getByte = _$jni.ProtectedJniExtensions
    .lookup<_$jni.NativeFunction<_$jni.JniResult Function(_$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, _$jni.VarArgs<(_$jni.Int32,)>)>>('globalEnv_CallByteMethod')
    .asFunction<_$jni.JniResult Function(_$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, int)>();
  /// from: `public final byte -deprecated_getByte(int i)`
  int -deprecated_getByte(int i, ){
    
    return _-deprecated_getByte(reference.pointer, _id_-deprecated_getByte as _$jni.JMethodIDPtr, i).byte;
  }

  static final _id_-deprecated_size = _class.instanceMethodId(
    r'-deprecated_size',
    r'()I',
  );

  static final _-deprecated_size = _$jni.ProtectedJniExtensions
    .lookup<_$jni.NativeFunction<_$jni.JniResult Function(_$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, )>>('globalEnv_CallIntMethod')
    .asFunction<_$jni.JniResult Function(_$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, )>();
  /// from: `public final int -deprecated_size()`
  int -deprecated_size(){
    
    return _-deprecated_size(reference.pointer, _id_-deprecated_size as _$jni.JMethodIDPtr).integer;
  }

}
final class $ByteString$Type extends _$jni.JObjType<ByteString> {
  

  @_$jni.internal
  const $ByteString$Type(
    
  );

  @_$jni.internal
  @_$core.override
  String get signature => r'Lokio/ByteString;';

  @_$jni.internal
  @_$core.override
  ByteString fromReference(_$jni.JReference reference) => ByteString.fromReference(
    
    reference
  );

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($ByteString$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ByteString$Type) &&
        other is $ByteString$Type;
  }
}

/// from: `com.example.ok_http.WebSocketInterceptor$Companion`
class WebSocketInterceptor_Companion extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<WebSocketInterceptor_Companion> $type;

  

  @_$jni.internal
  WebSocketInterceptor_Companion.fromReference(
    
    _$jni.JReference reference,
  ) :
    $type = type,
    super.fromReference(
      
      reference
    );

  static final _class = _$jni.JClass.forName(r'com/example/ok_http/WebSocketInterceptor$Companion');

      /// The type which includes information such as the signature of this class.
static const type = $WebSocketInterceptor_Companion$Type();
}
final class $WebSocketInterceptor_Companion$Type extends _$jni.JObjType<WebSocketInterceptor_Companion> {
  

  @_$jni.internal
  const $WebSocketInterceptor_Companion$Type(
    
  );

  @_$jni.internal
  @_$core.override
  String get signature => r'Lcom/example/ok_http/WebSocketInterceptor$Companion;';

  @_$jni.internal
  @_$core.override
  WebSocketInterceptor_Companion fromReference(_$jni.JReference reference) => WebSocketInterceptor_Companion.fromReference(
    
    reference
  );

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($WebSocketInterceptor_Companion$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($WebSocketInterceptor_Companion$Type) &&
        other is $WebSocketInterceptor_Companion$Type;
  }
}

/// from: `com.example.ok_http.WebSocketInterceptor`
class WebSocketInterceptor extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<WebSocketInterceptor> $type;

  

  @_$jni.internal
  WebSocketInterceptor.fromReference(
    
    _$jni.JReference reference,
  ) :
    $type = type,
    super.fromReference(
      
      reference
    );

  static final _class = _$jni.JClass.forName(r'com/example/ok_http/WebSocketInterceptor');

      /// The type which includes information such as the signature of this class.
static const type = $WebSocketInterceptor$Type();
  static final _id_Companion =
      _class.staticFieldId(
        r'Companion',
        r'Lcom/example/ok_http/WebSocketInterceptor$Companion;',
      );
  /// from: `static public final com.example.ok_http.WebSocketInterceptor$Companion Companion`
  /// The returned object must be released after use, by calling the [release] method.
static WebSocketInterceptor_Companion get Companion => _id_Companion.get(_class, const $WebSocketInterceptor_Companion$Type());

}
final class $WebSocketInterceptor$Type extends _$jni.JObjType<WebSocketInterceptor> {
  

  @_$jni.internal
  const $WebSocketInterceptor$Type(
    
  );

  @_$jni.internal
  @_$core.override
  String get signature => r'Lcom/example/ok_http/WebSocketInterceptor;';

  @_$jni.internal
  @_$core.override
  WebSocketInterceptor fromReference(_$jni.JReference reference) => WebSocketInterceptor.fromReference(
    
    reference
  );

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($WebSocketInterceptor$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($WebSocketInterceptor$Type) &&
        other is $WebSocketInterceptor$Type;
  }
}

/// from: `java.util.concurrent.TimeUnit`
class TimeUnit extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<TimeUnit> $type;

  

  @_$jni.internal
  TimeUnit.fromReference(
    
    _$jni.JReference reference,
  ) :
    $type = type,
    super.fromReference(
      
      reference
    );

  static final _class = _$jni.JClass.forName(r'java/util/concurrent/TimeUnit');

      /// The type which includes information such as the signature of this class.
static const type = $TimeUnit$Type();
  static final _id_NANOSECONDS =
      _class.staticFieldId(
        r'NANOSECONDS',
        r'Ljava/util/concurrent/TimeUnit;',
      );
  /// from: `static public final java.util.concurrent.TimeUnit NANOSECONDS`
  /// The returned object must be released after use, by calling the [release] method.
static TimeUnit get NANOSECONDS => _id_NANOSECONDS.get(_class, const $TimeUnit$Type());

  static final _id_MICROSECONDS =
      _class.staticFieldId(
        r'MICROSECONDS',
        r'Ljava/util/concurrent/TimeUnit;',
      );
  /// from: `static public final java.util.concurrent.TimeUnit MICROSECONDS`
  /// The returned object must be released after use, by calling the [release] method.
static TimeUnit get MICROSECONDS => _id_MICROSECONDS.get(_class, const $TimeUnit$Type());

  static final _id_MILLISECONDS =
      _class.staticFieldId(
        r'MILLISECONDS',
        r'Ljava/util/concurrent/TimeUnit;',
      );
  /// from: `static public final java.util.concurrent.TimeUnit MILLISECONDS`
  /// The returned object must be released after use, by calling the [release] method.
static TimeUnit get MILLISECONDS => _id_MILLISECONDS.get(_class, const $TimeUnit$Type());

  static final _id_SECONDS =
      _class.staticFieldId(
        r'SECONDS',
        r'Ljava/util/concurrent/TimeUnit;',
      );
  /// from: `static public final java.util.concurrent.TimeUnit SECONDS`
  /// The returned object must be released after use, by calling the [release] method.
static TimeUnit get SECONDS => _id_SECONDS.get(_class, const $TimeUnit$Type());

  static final _id_MINUTES =
      _class.staticFieldId(
        r'MINUTES',
        r'Ljava/util/concurrent/TimeUnit;',
      );
  /// from: `static public final java.util.concurrent.TimeUnit MINUTES`
  /// The returned object must be released after use, by calling the [release] method.
static TimeUnit get MINUTES => _id_MINUTES.get(_class, const $TimeUnit$Type());

  static final _id_HOURS =
      _class.staticFieldId(
        r'HOURS',
        r'Ljava/util/concurrent/TimeUnit;',
      );
  /// from: `static public final java.util.concurrent.TimeUnit HOURS`
  /// The returned object must be released after use, by calling the [release] method.
static TimeUnit get HOURS => _id_HOURS.get(_class, const $TimeUnit$Type());

  static final _id_DAYS =
      _class.staticFieldId(
        r'DAYS',
        r'Ljava/util/concurrent/TimeUnit;',
      );
  /// from: `static public final java.util.concurrent.TimeUnit DAYS`
  /// The returned object must be released after use, by calling the [release] method.
static TimeUnit get DAYS => _id_DAYS.get(_class, const $TimeUnit$Type());

}
final class $TimeUnit$Type extends _$jni.JObjType<TimeUnit> {
  

  @_$jni.internal
  const $TimeUnit$Type(
    
  );

  @_$jni.internal
  @_$core.override
  String get signature => r'Ljava/util/concurrent/TimeUnit;';

  @_$jni.internal
  @_$core.override
  TimeUnit fromReference(_$jni.JReference reference) => TimeUnit.fromReference(
    
    reference
  );

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($TimeUnit$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($TimeUnit$Type) &&
        other is $TimeUnit$Type;
  }
}

